
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>

// #include "include/libdivide.h"

#include "common/MathHelper.hpp"
#include "common/rng.hpp"
#include "layers.hpp"

#include "terrain/biomes/biome_t.hpp"
#include "terrain/noise/noise.hpp"


//==============================================================================
//                              MC Seed Helpers
//==============================================================================

/**
 * The seed pipeline:
 *
 * getLayerSalt(n)                -> layerSalt (layerStack)
 * layerSalt (layerStack), worldSeed (ws) -> startSalt (st), startSeed (ss)
 * startSeed (ss), coords (x,z)   -> chunkSeed (cs)
 *
 * The chunkSeed alone is enough to generate the first PRNG integer with:
 *   mcFirstInt<mod>(cs)
 * subsequent PRNG integers are generated by stepping the chunkSeed forwards,
 * salted with startSalt:
 *   cs_next = mcStepSeed(cs, st)
 */

static u64 mcStepSeed(c_u64 s, c_u64 salt) {
    return s * (s * 6364136223846793005ULL + 1442695040888963407ULL) + salt;
}

MU u64 mcFirstInt_Calls = 0;
MU u64 mcFirstIsZero_Calls = 0;


template <int MOD>
static int mcFirstInt(c_u64 s) {
    // mcFirstInt_Calls++;
    int ret = static_cast<i32>((static_cast<i64>(s) >> 24) % MOD);
    if (ret < 0) ret += MOD;
    return ret;
}



static int mcFirstInt(c_u64 s, c_int mod) {
    // mcFirstInt_Calls++;
    int ret = static_cast<i32>((static_cast<i64>(s) >> 24) % mod);
    if (ret < 0) ret += mod;
    return ret;
}

MU static int mcFirstIsZero(c_u64 s, c_int mod) {
    return static_cast<i32>((static_cast<i64>(s) >> 24) % mod) == 0;
}


template <int MOD>
static bool mcFirstIsZero(c_u64 s) {
    return static_cast<i32>((static_cast<i64>(s) >> 24) % MOD) == 0;
    // static const libdivide::libdivide_s64_t divider = libdivide::libdivide_s64_gen(MOD);
    // if constexpr (MOD == 2 || MOD == 4) {
    //     return ((static_cast<i64>(s) >> 24) & (MOD - 1)) == 0;
    // } else {
    //     return static_cast<i32>((static_cast<i64>(s) >> 24) % MOD) == 0;
    //     // i64 val = static_cast<i64>(s) >> 24;
    //     // i64 q = libdivide::libdivide_s64_do(val, &divider);
    //     // return (q * MOD == val);
    // }
}


static u64 getChunkSeed(c_u64 ss, c_int x, c_int z) {
    u64 cs = ss + static_cast<u64>(x);
    cs = mcStepSeed(cs, static_cast<u64>(z));
    cs = mcStepSeed(cs, static_cast<u64>(x));
    cs = mcStepSeed(cs, static_cast<u64>(z));
    return cs;
}

static u64 getLayerSalt(c_u64 salt) {
    u64 ls = mcStepSeed(salt, salt);
    ls = mcStepSeed(ls, salt);
    ls = mcStepSeed(ls, salt);
    return ls;
}

static u64 getStartSalt(c_u64 ws, c_u64 ls) {
    u64 st = ws;
    st = mcStepSeed(st, ls);
    st = mcStepSeed(st, ls);
    st = mcStepSeed(st, ls);
    return st;
}

MU static u64 getStartSeed(c_u64 ws, c_u64 ls) {
    u64 ss = ws;
    ss = getStartSalt(ss, ls);
    ss = mcStepSeed(ss, 0);
    return ss;
}

//==============================================================================
// Essentials
//==============================================================================


/**
 * @brief Checks if a biome exists for a given Minecraft version and ID.
 * @param mc Minecraft version.
 * @param id The biome ID.
 * @return 1 if the biome exists, 0 otherwise.
 */
int biomeExists(const MCVERSION mc, const biome_t id) {
    if (id >= ocean && id <= mountain_edge) return 1;
    if (id >= jungle && id <= jungle_hills) return mc >= MC_1_2;
    if (id >= jungle_edge && id <= badlands_plateau) return mc >= MC_1_7;
    if (id >= small_end_islands && id <= end_barrens) return mc >= MC_1_9;
    if (id >= warm_ocean && id <= deep_frozen_ocean) return mc >= MC_1_13;

    switch (id) {
        case the_void:
            return mc >= MC_1_9;
        case sunflower_plains:
        case desert_lakes:
        case gravelly_mountains:
        case flower_forest:
        case taiga_mountains:
        case swamp_hills:
        case ice_spikes:
        case modified_jungle:
        case modified_jungle_edge:
        case tall_birch_forest:
        case tall_birch_hills:
        case dark_forest_hills:
        case snowy_taiga_mountains:
        case giant_spruce_taiga:
        case giant_spruce_taiga_hills:
        case modified_gravelly_mountains:
        case shattered_savanna:
        case shattered_savanna_plateau:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
            return mc >= MC_1_7;
        case bamboo_jungle:
        case bamboo_jungle_hills:
            return mc >= MC_1_14;
        default:
            return 0;
    }
}

/**
 * @brief Checks if a biome is part of the Overworld.
 * @param mc Minecraft version.
 * @param id The biome ID.
 * @return 1 if the biome is in the Overworld, 0 otherwise.
 */
MU int isOverworld(const MCVERSION mc, const biome_t id) {
    if (!biomeExists(mc, id)) return 0;

    if (id >= small_end_islands && id <= end_barrens) return 0;

    switch (id) {
        case nether_wastes:
        case the_end:
            return 0;
        case frozen_ocean:
            return mc <= MC_1_6 || mc >= MC_1_13;
        case mountain_edge:
            return mc <= MC_1_6;
        case deep_warm_ocean:
        case the_void:
            return 0;
        case tall_birch_hills:
            return mc <= MC_1_8 || mc >= MC_1_11;
        default:
            return 1;
    }
}

/**
 * @brief Retrieves the mutated variant of a biome.
 * @param mc Minecraft version.
 * @param id The biome ID.
 * @return The ID of the mutated biome.
 */
biome_t getMutated(const MCVERSION mc, const biome_t id) {
    switch (id) {
        case plains:
            return sunflower_plains;
        case desert:
            return desert_lakes;
        case mountains:
            return gravelly_mountains;
        case forest:
            return flower_forest;
        case taiga:
            return taiga_mountains;
        case swamp:
            return swamp_hills;
        case snowy_tundra:
            return ice_spikes;
        case jungle:
            return modified_jungle;
        case jungle_edge:
            return modified_jungle_edge;
            // emulate MC-98995
        case birch_forest:
            return (mc >= MC_1_9 && mc <= MC_1_10) ? tall_birch_hills : tall_birch_forest;
        case birch_forest_hills:
            return (mc >= MC_1_9 && mc <= MC_1_10) ? none : tall_birch_hills;
        case dark_forest:
            return dark_forest_hills;
        case snowy_taiga:
            return snowy_taiga_mountains;
        case giant_tree_taiga:
            return giant_spruce_taiga;
        case giant_tree_taiga_hills:
            return giant_spruce_taiga_hills;
        case wooded_mountains:
            return modified_gravelly_mountains;
        case savanna:
            return shattered_savanna;
        case savanna_plateau:
            return shattered_savanna_plateau;
        case badlands:
            return eroded_badlands;
        case wooded_badlands_plateau:
            return modified_wooded_badlands_plateau;
        case badlands_plateau:
            return modified_badlands_plateau;
        default:
            return none;
    }
}

/**
 * @brief Retrieves the category of a biome.
 * @param mc Minecraft version.
 * @param id The biome ID.
 * @return The category of the biome.
 */
int getCategory(MU MCVERSION mc, const biome_t id) {
    switch (id) {
        case beach:
        case snowy_beach:
            return beach;

        case desert:
        case desert_hills:
        case desert_lakes:
            return desert;

        case mountains:
        case mountain_edge:
        case wooded_mountains:
        case gravelly_mountains:
        case modified_gravelly_mountains:
            return mountains;

        case forest:
        case wooded_hills:
        case birch_forest:
        case birch_forest_hills:
        case dark_forest:
        case flower_forest:
        case tall_birch_forest:
        case tall_birch_hills:
        case dark_forest_hills:
            return forest;

        case snowy_tundra:
        case snowy_mountains:
        case ice_spikes:
            return snowy_tundra;

        case jungle:
        case jungle_hills:
        case jungle_edge:
        case modified_jungle:
        case modified_jungle_edge:
        case bamboo_jungle:
        case bamboo_jungle_hills:
            return jungle;

        case badlands:
        case wooded_badlands_plateau:
        case badlands_plateau:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
            return mesa;


        case mushroom_fields:
        case mushroom_field_shore:
            return mushroom_fields;

        case stone_shore:
            return stone_shore;

        case ocean:
        case frozen_ocean:
        case deep_ocean:
        case warm_ocean:
        case lukewarm_ocean:
        case cold_ocean:
        case deep_warm_ocean:
        case deep_lukewarm_ocean:
        case deep_cold_ocean:
        case deep_frozen_ocean:
            return ocean;

        case plains:
        case sunflower_plains:
            return plains;

        case river:
        case frozen_river:
            return river;

        case savanna:
        case savanna_plateau:
        case shattered_savanna:
        case shattered_savanna_plateau:
            return savanna;

        case swamp:
        case swamp_hills:
            return swamp;

        case taiga:
        case taiga_hills:
        case snowy_taiga:
        case snowy_taiga_hills:
        case giant_tree_taiga:
        case giant_tree_taiga_hills:
        case taiga_mountains:
        case snowy_taiga_mountains:
        case giant_spruce_taiga:
        case giant_spruce_taiga_hills:
            return taiga;

        default:
            return none;
    }
}

/**
 * @brief Checks if two biomes are similar.
 * @param mc Minecraft version.
 * @param id1 The first biome ID.
 * @param id2 The second biome ID.
 * @return 1 if the biomes are similar, 0 otherwise.
 */
int areSimilar(const MCVERSION mc, const biome_t id1, const biome_t id2) {
    if (id1 == id2) return 1;

    if (id1 == wooded_badlands_plateau || id1 == badlands_plateau)
        return id2 == wooded_badlands_plateau || id2 == badlands_plateau;

    return getCategory(mc, id1) == getCategory(mc, id2);
}

/**
 * @brief Checks if a biome is a mesa biome.
 * @param id The biome ID.
 * @return 1 if the biome is a mesa biome, 0 otherwise.
 */
int isMesa(const biome_t id) {
    switch (id) {
        case badlands:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
        case wooded_badlands_plateau:
        case badlands_plateau:
            return 1;
        default:
            return 0;
    }
}

/**
 * @brief Checks if a biome is a shallow ocean biome.
 * @param id The biome ID.
 * @return 1 if the biome is a shallow ocean biome, 0 otherwise.
 */
int isShallowOcean(const biome_t id) {
    static constexpr u64 shallow_bits = makeBiomeBitmask<
            ocean, frozen_ocean, warm_ocean, lukewarm_ocean, cold_ocean>();
    const u32 uid = static_cast<u32>(id);
    return uid < 64 && ((1ULL << uid) & shallow_bits);
}

/**
 * @brief Checks if a biome is a deep ocean biome.
 * @param id The biome ID.
 * @return 1 if the biome is a deep ocean biome, 0 otherwise.
 */
int isDeepOcean(const biome_t id) {
    static constexpr u64 deep_bits = makeBiomeBitmask<
            deep_ocean, deep_warm_ocean, deep_lukewarm_ocean,
            deep_cold_ocean, deep_frozen_ocean>();
    const u32 uid = static_cast<u32>(id);
    return uid < 64 && ((1ULL << uid) & deep_bits);
}

/**
 * @brief Checks if a biome is oceanic.
 * @param id The biome ID.
 * @return 1 if the biome is oceanic, 0 otherwise.
 */
int isOceanic(const biome_t id) {
    static constexpr u64 ocean_bits = makeBiomeBitmask<
            ocean, frozen_ocean, warm_ocean, lukewarm_ocean, cold_ocean, deep_ocean,
            deep_warm_ocean, deep_lukewarm_ocean, deep_cold_ocean, deep_frozen_ocean>();
    const u32 uid = static_cast<u32>(id);
    return uid < 64 && ((1ULL << uid) & ocean_bits);
}

/**
 * @brief Checks if a biome is snowy.
 * @param id The biome ID.
 * @return 1 if the biome is snowy, 0 otherwise.
 */
int isSnowy(const biome_t id) {
    switch (id) {
        case frozen_ocean:
        case frozen_river:
        case snowy_tundra:
        case snowy_mountains:
        case snowy_beach:
        case snowy_taiga:
        case snowy_taiga_hills:
        case ice_spikes:
        case snowy_taiga_mountains:
            return 1;
        default:
            return 0;
    }
}


/**
 * @brief Applies the given world seed to the layer and all dependent layers.
 * @param layer Pointer to the layer.
 * @param worldSeed The world seed to apply.
 */
void setLayerSeed(Layer* layer, c_u64 worldSeed) {
    if (layer->p2 != nullptr) setLayerSeed(layer->p2, worldSeed);

    if (layer->p1 != nullptr) setLayerSeed(layer->p1, worldSeed);

    c_u64 ls = layer->layerSalt;
    if (ls == 0) { // Pre 1.13 the Hills branch stays zero-initialized
        layer->startSalt = 0;
        layer->startSeed = 0;
    } else {
        u64 st = worldSeed;
        st = mcStepSeed(st, ls);
        st = mcStepSeed(st, ls);
        st = mcStepSeed(st, ls);

        layer->startSalt = st;
        layer->startSeed = mcStepSeed(st, 0);
    }
}



/**
 * @brief Sets up a layer with the specified parameters.
 * @param l Pointer to the layer.
 * @param map Function pointer for the layer's mapping function.
 * @param theMc Minecraft version.
 * @param zoom Zoom factor for the layer.
 * @param edge Maximum border required from the parent layer.
 * @param saltBase Base salt for the layer.
 * @param p Pointer to the first parent layer.
 * @param p2 Pointer to the second parent layer.
 * @return Pointer to the configured layer.
 */
Layer* setupLayer(Layer* l, mapFunc_t* map, const MCVERSION theMc, c_i8 zoom, c_i8 edge,
                  c_u64 saltBase, Layer* p, Layer* p2) {
    //Layer *l = g->layers + layerId;
    l->getMap = map;
    l->mc = theMc;
    l->zoom = zoom;
    l->edge = edge;
    l->scale = 0;
    if (saltBase == 0) l->layerSalt = saltBase;
    else
        l->layerSalt = getLayerSalt(saltBase);
    l->startSalt = 0;
    l->startSeed = 0;
    l->p1 = p;
    l->p2 = p2;
    return l;
}


/**
 * @brief Sets up the scale for a layer.
 * @param l Pointer to the layer.
 * @param scale The scale to set.
 */
void setupScale(Layer* l, c_int scale) {
    l->scale = scale;
    if (l->p1) setupScale(l->p1, scale * l->zoom);
    if (l->p2) setupScale(l->p2, scale * l->zoom);
}

// TODO: BIOMES FOR EARLY VERSIONS (before elytra)
/**
 * @brief Sets up the layer stack for biome generation.
 * @param layerStack Pointer to the LayerStack structure.
 * @param lceVersion LCE version.
 * @param biomeSize Biome size scale.
 */
void setupLayerStack(LayerStack* layerStack, const LCEVERSION lceVersion, const lce::BIOMESCALE biomeSize) {

    const MCVERSION mc = getMCVersion(lceVersion);
    memset(layerStack, 0, sizeof(LayerStack));
    Layer *l = layerStack->layers;
    // L: layer
    // M: mapping function
    // V: minecraft version
    // Z: zoom
    // E: edge
    // S: salt base
    // P1: parent 1
    // P2: parent 2

    //             L                       M               V   Z  E  S     P1 P2
    Layer *p = setupLayer(l + L_CONTINENT_4096, mapContinent, mc, 1, 0, 1, nullptr, nullptr);
    p = setupLayer(l + L_ZOOM_2048, mapZoomFuzzy, mc, 2, 3, 2000, p, nullptr);
    p = setupLayer(l + L_LAND_2048, mapLand, mc, 1, 2, 1, p, nullptr);
    p = setupLayer(l + L_ZOOM_1024, mapZoom, mc, 2, 3, 2001, p, nullptr);
    p = setupLayer(l + L_LAND_1024_A, mapLand, mc, 1, 2, 2, p, nullptr);

    //             L                   M               V   Z  E  S     P1 P2
    p = setupLayer(l + L_LAND_1024_B, mapLand, mc, 1, 2, 50, p, nullptr);
    p = setupLayer(l + L_LAND_1024_C, mapLand, mc, 1, 2, 70, p, nullptr);
    p = setupLayer(l + L_ISLAND_1024, mapIsland, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_SNOW_1024, mapSnow, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_LAND_1024_D, mapLand, mc, 1, 2, 3, p, nullptr);
    p = setupLayer(l + L_COOL_1024, mapCoolWarm, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_HEAT_1024, mapHeatIce, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_SPECIAL_1024, mapSpecial, mc, 1, 2, 3, p, nullptr);
    p = setupLayer(l + L_ZOOM_512, mapZoom, mc, 2, 3, 2002, p, nullptr);
    p = setupLayer(l + L_ZOOM_256, mapZoom, mc, 2, 3, 2003, p, nullptr);
    p = setupLayer(l + L_LAND_256, mapLand, mc, 1, 2, 4, p, nullptr);
    if (biomeSize != lce::BIOMESCALE::SMALL) p = setupLayer(l + L_MUSHROOM_256, mapMushroom, mc, 1, 2, 5, p, nullptr);
    p = setupLayer(l + L_DEEP_OCEAN_256, mapDeepOcean, mc, 1, 2, 4, p, nullptr);
    p = setupLayer(l + L_BIOME_256, mapBiome, mc, 1, 0, 200, p, nullptr);
    if (mc >= MC_1_14) p = setupLayer(l + L_BAMBOO_256, mapBamboo, mc, 1, 0, 1001, p, nullptr);

    if (biomeSize >= lce::BIOMESCALE::MEDIUM) p = setupLayer(l + L_ZOOM_128, mapZoom, mc, 2, 3, 1000, p, nullptr);
    if (biomeSize >= lce::BIOMESCALE::LARGE) p = setupLayer(l + L_ZOOM_64, mapZoom, mc, 2, 3, 1001, p, nullptr);

    p = setupLayer(l + L_BIOME_EDGE_64, mapBiomeEdge, mc, 1, 2, 1000, p, nullptr);
    // river noise layer chain, also used to determine where hills const generate
    p = setupLayer(l + L_RIVER_INIT_256, mapRiverInit, mc, 1, 0, 100, l + L_DEEP_OCEAN_256, nullptr);

    // latest WII U has oceans, so I use 1.13 but these salts are 0 so this works like 1.12-
    // if (mc <= MC_1_12)
    // {
    p = setupLayer(l + L_ZOOM_128_HILLS, mapZoom, mc, 2, 3, 0, p, nullptr);
    p = setupLayer(l + L_ZOOM_64_HILLS, mapZoom, mc, 2, 3, 0, p, nullptr);
    // }
    // else if (mc >= MC_1_1)
    // {
    // p = setupLayer(l+L_ZOOM_128_HILLS, mapZoom,        mc, 2, 3, 1000, p, 0);
    // p = setupLayer(l+L_ZOOM_64_HILLS,  mapZoom,        mc, 2, 3, 1001, p, 0);
    // }


    p = setupLayer(l + L_HILLS_64, mapHills, mc, 1, 2, 1000, l + L_BIOME_EDGE_64, l + L_ZOOM_64_HILLS);

    p = setupLayer(l + L_SUNFLOWER_64, mapSunflower, mc, 1, 0, 1001, p, nullptr);

    // for i in 0..biomeScale

    // iteration 0
    p = setupLayer(l + L_ZOOM_32, mapZoom, mc, 2, 3, 1000, p, nullptr);
    p = setupLayer(l + L_LAND_32, mapLand, mc, 1, 2, 3, p, nullptr);
    if (biomeSize == lce::BIOMESCALE::SMALL) p = setupLayer(l + L_A_MUSHROOM_32, mapMushroom, mc, 1, 2, 5, p, nullptr);

    // iteration 1
    p = setupLayer(l + L_ZOOM_16, mapZoom, mc, 2, 3, 1001, p, nullptr);
    if (biomeSize == lce::BIOMESCALE::SMALL) p = setupLayer(l + L_G_MUSHROOM_16, mapGiantMushroom, mc, 1, 2, 5, p, nullptr);
    p = setupLayer(l + L_SHORE_16, mapShore, mc, 1, 2, 1000, p, nullptr);

    // iteration 2
    p = setupLayer(l + L_ZOOM_8, mapZoom, mc, 2, 3, 1002, p, nullptr);

    // iteration 3
    p = setupLayer(l + L_ZOOM_4, mapZoom, mc, 2, 3, 1003, p, nullptr);
    p = setupLayer(l + L_SMOOTH_4, mapSmooth, mc, 1, 2, 1000, p, nullptr);

    // river layer chain
    p = setupLayer(l + L_ZOOM_128_RIVER, mapZoom, mc, 2, 3, 1000, l + L_RIVER_INIT_256, nullptr);
    p = setupLayer(l + L_ZOOM_64_RIVER, mapZoom, mc, 2, 3, 1001, p, nullptr);
    p = setupLayer(l + L_ZOOM_32_RIVER, mapZoom, mc, 2, 3, 1000, p, nullptr);
    p = setupLayer(l + L_ZOOM_16_RIVER, mapZoom, mc, 2, 3, 1001, p, nullptr);
    p = setupLayer(l + L_ZOOM_8_RIVER, mapZoom, mc, 2, 3, 1002, p, nullptr);
    p = setupLayer(l + L_ZOOM_4_RIVER, mapZoom, mc, 2, 3, 1003, p, nullptr);

    p = setupLayer(l + L_RIVER_4, mapRiver, mc, 1, 2, 1, p, nullptr);
    p = setupLayer(l + L_SMOOTH_4_RIVER, mapSmooth, mc, 1, 2, 1000, p, nullptr);

    p = setupLayer(l + L_RIVER_MIX_4, mapRiverMix, mc, 1, 0, 100, l + L_SMOOTH_4, l + L_SMOOTH_4_RIVER);

    c_int hasOceans = mc >= MCVERSION::MC_1_13;

    if (hasOceans) {
        // ocean variants
        p = setupLayer(l + L_OCEAN_TEMP_256, mapOceanTemp, mc, 1, 0, 2, nullptr, nullptr);
        // p->noise = &g->oceanRnd;
        p = setupLayer(l + L_OCEAN_EDGE_256, mapOceanEdge, mc, 1, 1, 2, p, nullptr);
        p = setupLayer(l + L_ZOOM_128_OCEAN, mapZoom, mc, 2, 3, 2001, p, nullptr);
        p = setupLayer(l + L_ZOOM_64_OCEAN, mapZoom, mc, 2, 3, 2002, p, nullptr);
        p = setupLayer(l + L_ZOOM_32_OCEAN, mapZoom, mc, 2, 3, 2003, p, nullptr);
        p = setupLayer(l + L_ZOOM_16_OCEAN, mapZoom, mc, 2, 3, 2004, p, nullptr);
        p = setupLayer(l + L_ZOOM_8_OCEAN, mapZoom, mc, 2, 3, 2005, p, nullptr);
        p = setupLayer(l + L_ZOOM_4_OCEAN, mapZoom, mc, 2, 3, 2006, p, nullptr);
        p = setupLayer(l + L_OCEAN_MIX_4, mapOceanMix, mc, 1, 17, 100, l + L_RIVER_MIX_4, l + L_ZOOM_4_OCEAN);
    }

    p = setupLayer(l + L_VORONOI_1, mapVoronoi114, mc, 4, 3, 10, p, nullptr);

    layerStack->entry_1 = p;
    layerStack->entry_4 = l + (!hasOceans ? L_RIVER_MIX_4 : L_OCEAN_MIX_4);
    if (mc >= MC_1_1) {
        layerStack->entry_16 = l + (mc <= MC_1_6 ? L_SWAMP_RIVER_16 : L_SHORE_16);
        layerStack->entry_64 = l + (mc <= MC_1_7 ? L_HILLS_64 : L_SUNFLOWER_64);
        layerStack->entry_256 = l + (mc <= MC_1_14 ? L_BIOME_256 : L_BAMBOO_256);
    } else {
        layerStack->entry_16 = l + L_ZOOM_16;
        layerStack->entry_64 = l + L_ZOOM_64;
        layerStack->entry_256 = l + L_BIOME_256;
    }
    setupScale(layerStack->entry_1, 1);
}

/**
 * @brief Retrieves the maximum area for a layer.
 * Recursively calculates the minimum buffer size required to const generate an area
 * of the specified size from the current layer onwards.
 * @param layer Pointer to the layer.
 * @param areaX X-coordinate of the area.
 * @param areaZ Z-coordinate of the area.
 * @param maxX Pointer to store the maximum X-coordinate.
 * @param maxZ Pointer to store the maximum Z-coordinate.
 * @param siz Pointer to store the size of the area.
 */
void getMaxArea(const Layer* layer, int areaX, int areaZ, int* maxX, int* maxZ, size_t* siz) {
    if (layer == nullptr) return;

    // printf("edge: %d\n", layer->edge);

    areaX += layer->edge;
    areaZ += layer->edge;

    if (areaX > *maxX) *maxX = areaX;
    if (areaZ > *maxZ) *maxZ = areaZ;

    if (layer->zoom == 2) {
        areaX >>= 1;
        areaZ >>= 1;
    } else if (layer->zoom == 4) {
        areaX >>= 2;
        areaZ >>= 2;
    }

    // multi-layers and zoom-layers use a temporary copy of their parent area
    if (layer->p2 || layer->zoom != 1) *siz += static_cast<size_t>(areaX * areaZ);

    getMaxArea(layer->p1, areaX, areaZ, maxX, maxZ, siz);
    if (layer->p2) getMaxArea(layer->p2, areaX, areaZ, maxX, maxZ, siz);
}

/**
 * @brief Retrieves the minimum cache size for a layer.
 * @param layer Pointer to the layer.
 * @param sizeX Size of the area in the X direction.
 * @param sizeZ Size of the area in the Z direction.
 * @return The minimum cache size.
 */
size_t getMinLayerCacheSize(const Layer* layer, c_int sizeX, c_int sizeZ) {
    int maxX = sizeX;
    int maxZ = sizeZ;
    size_t bufferSize = 0;
    getMaxArea(layer, sizeX, sizeZ, &maxX, &maxZ, &bufferSize);
    return bufferSize + maxX * static_cast<size_t>(maxZ);
}

/**
 * @brief Generates an area for the specified layer.
 * const Generates the specified area using the current const generator settings and stores
 * the biomeIDs in 'out'.
 * The biomeIDs will be indexed in the form: out[x + z*areaWidth]
 * It is recommended that 'out' is allocated using allocCache() for the correct
 * buffer size.
 *
 * @param layer Pointer to the layer.
 * @param out Pointer to the output area.
 * @param areaX X-coordinate of the area.
 * @param areaZ Z-coordinate of the area.
 * @param areaWidth Width of the area.
 * @param areaHeight Height of the area.
 */
void genArea(const Layer* layer, biome_t* out, c_int areaX, c_int areaZ, c_int areaWidth, c_int areaHeight) {
    // TODO: this could be calloc because it's initializing to 0
    memset(out, 0, areaWidth * areaHeight * sizeof(*out));
    layer->getMap(layer, out, areaX, areaZ, areaWidth, areaHeight);
}


//==============================================================================
// Noise
//==============================================================================


/**
 * @brief Initializes surface noise for older versions.
 * @param rnd Pointer to the SurfaceNoise structure.
 * @param seed Pointer to the seed.
 * @param xzScale Scale factor for the XZ plane.
 * @param yScale Scale factor for the Y axis.
 * @param xzFactor Factor for the XZ plane.
 * @param yFactor Factor for the Y axis.
 */
MU void initSurfaceNoiseOld(SurfaceNoise* rnd, RNG& seed,
                         const double xzScale, const double yScale, const double xzFactor, const double yFactor) {
    rnd->xzScale = xzScale;
    rnd->yScale = yScale;
    rnd->xzFactor = xzFactor;
    rnd->yFactor = yFactor;
    octaveInit(&rnd->octaveMin, seed, rnd->oct + 0, -15, 16);
    octaveInit(&rnd->octaveMax, seed, rnd->oct + 16, -15, 16);
    octaveInit(&rnd->octaveMain, seed, rnd->oct + 32, -7, 8);
}

/**
 * @brief Initializes surface noise for the End biome.
 * @param rnd Pointer to the SurfaceNoise structure.
 * @param seed The seed to initialize with.
 */
void initSurfaceNoiseEnd(SurfaceNoise* rnd, c_u64 seed) {
    RNG rng;
    rng.setSeed(seed);
    initSurfaceNoiseOld(rnd, rng, 2.0, 1.0, 80.0, 160.0);
}


/**
 * @brief Samples surface noise at a specific position.
 * @param g Pointer to the generator.
 * @param rnd Pointer to the SurfaceNoise structure.
 * @param x X-coordinate.
 * @param y Y-coordinate.
 * @param z Z-coordinate.
 * @return The sampled noise value.
 */
double sampleSurfaceNoise(const Generator* g, const SurfaceNoise* rnd, c_int x, c_int y, c_int z) {
    c_double xzScale = 684.412 * rnd->xzScale;
    c_double yScale = 684.412 * rnd->yScale;
    c_double xzStep = xzScale / rnd->xzFactor;
    c_double yStep = yScale / rnd->yFactor;

    double minNoise = 0;
    double maxNoise = 0;
    double mainNoise = 0;
    double persist = 1.0;

    for (int i = 0; i < 16; i++) {
        double dx = maintainPrecision(x * xzScale * persist);
        double dy = maintainPrecision(y * yScale * persist);
        double dz = maintainPrecision(z * xzScale * persist);
        double sy = yScale * persist;
        double ty = y * sy;

        minNoise += samplePerlin(g, &rnd->octaveMin.octaves[i], dx, dy, dz, sy, ty) / persist;
        maxNoise += samplePerlin(g, &rnd->octaveMax.octaves[i], dx, dy, dz, sy, ty) / persist;

        if (i < 8) {
            dx = maintainPrecision(x * xzStep * persist);
            dy = maintainPrecision(y * yStep * persist);
            dz = maintainPrecision(z * xzStep * persist);
            sy = yStep * persist;
            ty = y * sy;
            mainNoise += samplePerlin(g, &rnd->octaveMain.octaves[i], dx, dy, dz, sy, ty) / persist;
        }
        persist /= 2.0;
    }

    return MathHelper::clampedLerp(0.5 + 0.05 * mainNoise, minNoise / 512.0, maxNoise / 512.0);
}

//==============================================================================
// End const Generation
//==============================================================================


/**
 * @brief Sets the seed for End biome noise generation.
 * @param en Pointer to the EndNoise structure.
 * @param seed The seed to set.
 */
void setEndSeed(EndNoise* en, const u64 seed) {
    RNG rng;
    rng.setSeed(seed);
    rng.advance<17292>();
    perlinInit(en, rng);
}


static float getEndHeightNoise(const EndNoise* en, c_int x, c_int z) {
    c_int hx = x / 2;
    c_int hz = z / 2;
    c_int oddX = x % 2;
    c_int oddZ = z % 2;

    i64 h = 64 * (x * static_cast<i64>(x) + z * static_cast<i64>(z));

    for (int j = -12; j <= 12; j++) {
        for (int i = -12; i <= 12; i++) {
            i64 rx = hx + i;
            i64 rz = hz + j;
            u16 v = 0;
            if (rx * rx + rz * rz > 4096 && sampleSimplex2D(en,
                                                            static_cast<double>(rx), static_cast<double>(rz)) < -0.9f) {
                v = (llabs(rx) * 3439 + llabs(rz) * 147) % 13 + 9;
                rx = (oddX - i * 2);
                rz = (oddZ - j * 2);
                c_i64 noise = (rx * rx + rz * rz) * v * v;
                if (noise < h) h = noise;
            }
        }
    }

    float ret = 100 - sqrtf(static_cast<float>(h));
    if (ret < -100) ret = -100;
    if (ret > 80) ret = 80;
    return ret;
}


static void sampleNoiseColumnEnd(const Generator* g, double column[], const SurfaceNoise* sn, const EndNoise* en, c_int x,
                          c_int z, c_int colymin, c_int colymax) {
    c_double depth = getEndHeightNoise(en, x, z) - 8.0F;
    for (int y = colymin; y <= colymax; y++) {
        double noise = sampleSurfaceNoise(g, sn, x, y, z);
        noise += depth; // falloff for the End is just the depth
        // clamp top and bottom slides from End settings
        noise = MathHelper::clampedLerp((32 + 46 - y) / 64.0, -3000, noise);
        noise = MathHelper::clampedLerp((y - 1) / 7.0, -30, noise);
        column[y - colymin] = noise;
    }
}


/**
 * Given bordering noise columns and a fractional position between those,
 * determine the surface block height (i.e. where the interpolated noise > 0).
 * Note that the noise columns should be of size: ncolxz[ colymax-colymin+1 ]
 */
int getSurfaceHeight(c_double ncol00[], c_double ncol01[], c_double ncol10[], c_double ncol11[],
                     c_int colymin, c_int colymax, c_int blockspercell, c_double dx, c_double dz) {
    for (int celly = colymax - 1; celly >= colymin; celly--) {
        c_int idx = celly - colymin;
        c_double v000 = ncol00[idx];
        c_double v001 = ncol01[idx];
        c_double v100 = ncol10[idx];
        c_double v101 = ncol11[idx];
        c_double v010 = ncol00[idx + 1];
        c_double v011 = ncol01[idx + 1];
        c_double v110 = ncol10[idx + 1];
        c_double v111 = ncol11[idx + 1];

        for (int y = blockspercell - 1; y >= 0; y--) {
            const double dy = y / static_cast<double>(blockspercell);
            const double noise = MathHelper::lerp3D(dy, dx, dz, // Note: not x, y, z
                                                    v000, v010, v100, v110, v001, v011, v101, v111);
            if (noise > 0) return celly * blockspercell + y;
        }
    }

    return 0;
}

/**
 * @brief Retrieves the surface height for the End biome.
 * @param g Pointer to the generator.
 * @param mc Minecraft version.
 * @param seed The world seed.
 * @param x X-coordinate.
 * @param z Z-coordinate.
 * @return The surface height.
 */
MU int getSurfaceHeightEnd(const Generator* g, const MCVERSION mc, c_u64 seed, c_int x, c_int z) {
    (void) mc;

    EndNoise en;
    setEndSeed(&en, seed);

    SurfaceNoise sn;
    initSurfaceNoiseEnd(&sn, seed);

    // end noise columns vary on a grid of cell size = eight
    c_int cellX = (x >> 3);
    c_int cellY = (z >> 3);
    c_double dx = (x & 7) / 8.0;
    c_double dz = (z & 7) / 8.0;

    constexpr int y0 = 0, y1 = 32, yn = y1 - y0 + 1;
    double ncol00[yn];
    double ncol01[yn];
    double ncol10[yn];
    double ncol11[yn];
    sampleNoiseColumnEnd(g, ncol00, &sn, &en, cellX, cellY, y0, y1);
    sampleNoiseColumnEnd(g, ncol01, &sn, &en, cellX, cellY + 1, y0, y1);
    sampleNoiseColumnEnd(g, ncol10, &sn, &en, cellX + 1, cellY, y0, y1);
    sampleNoiseColumnEnd(g, ncol11, &sn, &en, cellX + 1, cellY + 1, y0, y1);

    return getSurfaceHeight(ncol00, ncol01, ncol10, ncol11, y0, y1, 4, dx, dz);
}


//==============================================================================
// Layers
//==============================================================================

// convenience function used in several layers
static int isAny4(c_int id, c_int a, c_int b, c_int c, c_int d) {
    return id == a || id == b || id == c || id == d;
}


/**
 * @var mapContinent
 * @brief Mapping function for the continent layer.
 *        Previously known as mapIsland.
 * @ BufferIn  reads nothing
 * @ BufferOut writes { 0: ocean, 1: land }
 */
void mapContinent(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const u64 cs = getChunkSeed(ss, i + x, j + z);
            out[i + j * w] = static_cast<biome_t>(mcFirstIsZero<10>(cs));
        }
    }

    if (x > -w && x <= 0 && z > -h && z <= 0) { out[-x + -z * w] = biome_t::plains; }
}


/**
 * @var mapZoomFuzzy
 * @brief Mapping function for applying a fuzzy zoom effect.
 * @ BufferIn  reads whatever parent has
 * @ BufferOut writes whatever parent has, just smoothed.
 */
void mapZoomFuzzy(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x >> 1;
    c_int pZ = z >> 1;
    c_int pW = ((x + w) >> 1) - pX + 1;
    c_int pH = ((z + h) >> 1) - pZ + 1;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_int newW = pW << 1;
    biome_t v10, v11;
    biome_t* buf = out + pW * pH;

    c_auto st = static_cast<u32>(l->startSalt);
    c_auto ss = static_cast<u32>(l->startSeed);

    for (int j = 0; j < pH; j++) {
        int idx = (j << 1) * newW;

        biome_t v00 = out[(j + 0) * pW];
        biome_t v01 = out[(j + 1) * pW];

        for (int i = 0; i < pW; i++, v00 = v10, v01 = v11) {
            v10 = out[i + 1 + (j + 0) * pW];
            v11 = out[i + 1 + (j + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                buf[idx] = v00;
                buf[idx + 1] = v00;
                buf[idx + newW] = v00;
                buf[idx + newW + 1] = v00;
                idx += 2;
                continue;
            }

            c_int chunkX = static_cast<int>(static_cast<u32>(i + pX) << 1);
            c_int chunkZ = static_cast<int>(static_cast<u32>(j + pZ) << 1);

            u32 cs = ss;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;

            buf[idx] = v00;
            buf[idx + newW] = (cs >> 24) & 1 ? v01 : v00;
            idx++;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            buf[idx] = (cs >> 24) & 1 ? v10 : v00;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            c_int r = (int)((cs >> 24) & 3);
            buf[idx + newW] = r == 0 ? v00 : r == 1 ? v10 : r == 2 ? v01 : v11;
            idx++;
        }
    }

    for (int j = 0; j < h; j++) {
        memmove(&out[j * w], &buf[(j + (z & 1)) * newW + (x & 1)], w * sizeof(biome_t));
    }
}


static biome_t select4(u32 cs, c_u32 st, const biome_t v00, const biome_t v01, const biome_t v10, const biome_t v11) {
    biome_t v;
    c_int cv00 = (v00 == v10) + (v00 == v01) + (v00 == v11);
    c_int cv10 = (v10 == v01) + (v10 == v11);
    c_int cv01 = (v01 == v11);
    if (cv00 > cv10 && cv00 > cv01) {
        v = v00;
    } else if (cv10 > cv00) {
        v = v10;
    } else if (cv01 > cv00) {
        v = v01;
    } else {
        cs *= cs * 1284865837 + 4150755663;
        cs += st;
        c_int r = (int)((cs >> 24) & 3);
        v = r == 0 ? v00 : r == 1 ? v10 : r == 2 ? v01 : v11;
    }
    return v;
}


/**
 * @var mapZoom
 * @brief Mapping function for applying a standard zoom effect.
 * This is the most common layer, and generally the second most performance
 * critical after mapAddIsland.
 * @ BufferIn  reads whatever parent has
 * @ BufferOut writes whatever parent has, just up-sampled.
 */
void mapZoom(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x >> 1;
    c_int pZ = z >> 1;
    c_int pW = ((x + w) >> 1) - pX + 1; // (w >> 1) + 2;
    c_int pH = ((z + h) >> 1) - pZ + 1; // (h >> 1) + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_int newW = pW << 1;
    biome_t v10, v11;
    biome_t* buf = out + pW * pH;

    c_auto st = static_cast<u32>(l->startSalt);
    c_auto ss = static_cast<u32>(l->startSeed);

    for (int j = 0; j < pH; j++) {
        int idx = (j << 1) * newW;

        biome_t v00 = out[(j + 0) * pW];
        biome_t v01 = out[(j + 1) * pW];

        for (int i = 0; i < pW; i++, v00 = v10, v01 = v11) {
            v10 = out[i + 1 + (j + 0) * pW];
            v11 = out[i + 1 + (j + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                buf[idx] = v00;
                buf[idx + 1] = v00;
                buf[idx + newW] = v00;
                buf[idx + newW + 1] = v00;
                idx += 2;
                continue;
            }

            c_int chunkX = static_cast<int>(static_cast<u32>(i + pX) << 1);
            c_int chunkZ = static_cast<int>(static_cast<u32>(j + pZ) << 1);

            u32 cs = ss;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;

            buf[idx] = v00;
            buf[idx + newW] = (cs >> 24) & 1 ? v01 : v00;
            idx++;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            buf[idx] = (cs >> 24) & 1 ? v10 : v00;

            buf[idx + newW] = select4(cs, st, v00, v01, v10, v11);

            idx++;
        }
    }

    for (int j = 0; j < h; j++) {
        memmove(&out[j * w], &buf[(j + (z & 1)) * newW + (x & 1)], w * sizeof(biome_t));
    }
}

/**
 * @var mapLand
 * @brief Mapping function for adding land to the layer.
 *        Previously known as mapAddIsland.
 * This is the most performance critical layer, especially for getBiomeAtPos.
 * @ BufferIn  reads { 0: ocean, 1: land, with exceptions }
 * @ BufferOut writes
 */
void mapLand(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    const u64 st = l->startSalt;
    const u64 ss = l->startSeed;
    u64 cs;

    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        biome_t v00 = vz0[0], vt0 = vz0[1];
        biome_t v02 = vz2[0], vt2 = vz2[1];

        for (int i = 0; i < w; i++) {
            const biome_t v11 = vz1[i + 1];
            const biome_t v20 = vz0[i + 2];
            const biome_t v22 = vz2[i + 2];
            biome_t v = v11;

            switch (v11) {
                case ocean:
                    if (v00 || v20 || v02 || v22) { // corners have non-ocean
                        /*
                        setChunkSeed(l,x+i,z+j);
                        int inc = 1;
                        if(v00 != 0 && mcNextInt(l,inc++) == 0) v = v00;
                        if(v20 != 0 && mcNextInt(l,inc++) == 0) v = v20;
                        if(v02 != 0 && mcNextInt(l,inc++) == 0) v = v02;
                        if(v22 != 0 && mcNextInt(l,inc++) == 0) v = v22;
                        if(mcNextInt(l,3) == 0) out[x + z*areaWidth] = v;
                        else if(v == 4)         out[x + z*areaWidth] = 4;
                        else                    out[x + z*areaWidth] = 0;
                        */

                        cs = getChunkSeed(ss, i + x, j + z);
                        int inc = 0;
                        v = biome_t::plains;

                        if (v00 != ocean) {
                            ++inc;
                            v = v00;
                            cs = mcStepSeed(cs, st);
                        }
                        if (v20 != ocean) {
                            if (++inc == 1 || mcFirstIsZero<2>(cs)) v = v20;
                            cs = mcStepSeed(cs, st);
                        }
                        if (v02 != ocean) {
                            switch (++inc) {
                                case 1:
                                    v = v02;
                                    break;
                                case 2:
                                    if (mcFirstIsZero<2>(cs)) v = v02;
                                    break;
                                default:
                                    if (mcFirstIsZero<3>(cs)) v = v02;
                            }
                            cs = mcStepSeed(cs, st);
                        }
                        if (v22 != ocean) {
                            switch (++inc) {
                                case 1:
                                    v = v22;
                                    break;
                                case 2:
                                    if (mcFirstIsZero<2>(cs)) v = v22;
                                    break;
                                case 3:
                                    if (mcFirstIsZero<3>(cs)) v = v22;
                                    break;
                                default:
                                    if (mcFirstIsZero<4>(cs)) v = v22;
                            }
                            cs = mcStepSeed(cs, st);
                        }

                        if (v != forest) {
                            if (!mcFirstIsZero<3>(cs)) v = ocean;
                        }
                    }
                    break;

                case forest:
                    break;

                default:
                    if (v00 == 0 || v20 == 0 || v02 == 0 || v22 == 0) {
                        cs = getChunkSeed(ss, i + x, j + z);
                        if (mcFirstIsZero<5>(cs)) v = biome_t::ocean;
                    }
            }

            out[i + j * w] = v;
            v00 = vt0;
            vt0 = v20;
            v02 = vt2;
            vt2 = v22;
        }
    }
}


/**
 * @var mapIsland
 * @brief Mapping function for removing excessive ocean areas.
 *        Previously known as mapRemoveTooMuchOcean.
 */
void mapIsland(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const biome_t v11 = out[i + 1 + (j + 1) * pW];
            out[i + j * w] = v11;

            if (v11 == static_cast<biome_t>(oceanic)) {
                if (out[i + 1 + (j + 0) * pW] != static_cast<biome_t>(oceanic)) continue;
                if (out[i + 2 + (j + 1) * pW] != static_cast<biome_t>(oceanic)) continue;
                if (out[i + 0 + (j + 1) * pW] != static_cast<biome_t>(oceanic)) continue;
                if (out[i + 1 + (j + 2) * pW] != static_cast<biome_t>(oceanic)) continue;

                const u64 cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero<2>(cs)) { out[i + j * w] = biome_t::plains; }
            }
        }
    }
}

/**
 * @var mapSnow
 * @brief Mapping function for adding snow to the layer.
 *        Previously known as mapAddSnow.
 */
void mapSnow(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const biome_t v11 = out[i + 1 + (j + 1) * pW];

            if (isShallowOcean(v11)) {
                out[i + j * w] = v11;
            } else {
                const u64 cs = getChunkSeed(ss, i + x, j + z);
                c_int r = mcFirstInt<6>(cs);
                int v;

                if (r == 0) v = freezing;
                else if (r <= 1)
                    v = cold;
                else
                    v = warm;
                // u8 temps[] = {Freezing, Cold, Warm, Warm, Warm, Warm};
                // v = temps[mcFirstInt<6>(cs)];

                out[i + j * w] = static_cast<biome_t>(v);
            }
        }
    }
}



/**
 * @var mapCoolWarm
 * @brief Mapping function for adjusting cool and warm areas.
 */
void mapCoolWarm(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v11 = out[i + 1 + (j + 1) * pW];

            if (v11 == static_cast<biome_t>(warm)) {
                c_int v10 = out[i + 1 + (j + 0) * pW];
                c_int v21 = out[i + 2 + (j + 1) * pW];
                c_int v01 = out[i + 0 + (j + 1) * pW];
                c_int v12 = out[i + 1 + (j + 2) * pW];

                if (isAny4(cold, v10, v21, v01, v12) || isAny4(freezing, v10, v21, v01, v12)) {
                    v11 = static_cast<biome_t>(lush);
                }
            }

            out[i + j * w] = v11;
        }
    }
}


/**
 * @var mapHeatIce
 * @brief Mapping function for adjusting heat and ice areas.
 */
void mapHeatIce(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v11 = out[i + 1 + (j + 1) * pW];

            if (v11 == static_cast<biome_t>(freezing)) {
                c_int v10 = out[i + 1 + (j + 0) * pW];
                c_int v21 = out[i + 2 + (j + 1) * pW];
                c_int v01 = out[i + 0 + (j + 1) * pW];
                c_int v12 = out[i + 1 + (j + 2) * pW];

                if (isAny4(warm, v10, v21, v01, v12) || isAny4(lush, v10, v21, v01, v12)) {
                    v11 = static_cast<biome_t>(cold);
                }
            }

            out[i + j * w] = v11;
        }
    }
}


/**
 * @var mapSpecial
 * @brief Mapping function for adding special features to the layer.
 */
void mapSpecial(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    l->p1->getMap(l->p1, out, x, z, w, h);


    const u64 st = l->startSalt;
    const u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            int v = out[i + j * w];
            if (v == 0) continue;

            u64 cs = getChunkSeed(ss, i + x, j + z);

            if (mcFirstIsZero<13>(cs)) {
                cs = mcStepSeed(cs, st);
                v |= (1 + mcFirstInt<15>(cs)) << 8 & 0xf00;
                // 1 to 1 mapping so 'out' can be overwritten immediately
                out[i + j * w] = static_cast<biome_t>(v);
            }
        }
    }
}


/**
 * @var mapMushroom
 * @brief Mapping function for adding mushroom islands.
 *        Previously known as mapAddMushroomIsland.
 */
void mapMushroom(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    const u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v11 = out[i + 1 + (j + 1) * pW];

            // surrounded by ocean?
            if (v11 == 0 &&
                !out[i + 0 + (j + 0) * pW] &&
                !out[i + 2 + (j + 0) * pW] &&
                !out[i + 0 + (j + 2) * pW] &&
                !out[i + 2 + (j + 2) * pW]) {
                const u64 cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero<100>(cs)) v11 = mushroom_fields;
            }

            out[i + j * w] = v11;
        }
    }
}


/**
 * @var mapDeepOcean
 * @brief Mapping function for adding deep ocean areas.
 */
void mapDeepOcean(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v11 = out[(i + 1) + (j + 1) * pW];

            if (isShallowOcean(v11)) {
                // count adjacent oceans
                int oceans = 0;
                if (isShallowOcean(out[(i + 1) + (j + 0) * pW])) oceans++;
                if (isShallowOcean(out[(i + 2) + (j + 1) * pW])) oceans++;
                if (isShallowOcean(out[(i + 0) + (j + 1) * pW])) oceans++;
                if (isShallowOcean(out[(i + 1) + (j + 2) * pW])) oceans++;

                if (oceans >= 4) {
                    switch (v11) {
                        case warm_ocean:
                            v11 = deep_warm_ocean;
                            break;
                        case lukewarm_ocean:
                            v11 = deep_lukewarm_ocean;
                            break;
                        case ocean:
                            v11 = deep_ocean;
                            break;
                        case cold_ocean:
                            v11 = deep_cold_ocean;
                            break;
                        case frozen_ocean:
                            v11 = deep_frozen_ocean;
                            break;
                        default:
                            v11 = deep_ocean;
                    }
                }
            }

            out[i + j * w] = v11;
        }
    }
}


constexpr biome_t warmBiomes[] = {desert, desert, desert, savanna, savanna, plains};
constexpr biome_t lushBiomes[] = {forest, dark_forest, mountains, plains, birch_forest, swamp};
constexpr biome_t coldBiomes[] = {forest, mountains, taiga, plains};
constexpr biome_t snowBiomes[] = {snowy_tundra, snowy_tundra, snowy_tundra, snowy_taiga};

constexpr biome_t oldBiomes[] = {desert, forest, mountains, swamp, plains, taiga, jungle};
constexpr biome_t oldBiomes11[] = {desert, forest, mountains, swamp, plains, taiga};
//c_int lushBiomesBE[] = {forest, dark_forest, mountains, plains, plains, plains, birch_forest, swamp};


/**
 * @var mapBiome
 * @brief Mapping function for assigning biomes to the layer.
 */
void mapBiome(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    l->p1->getMap(l->p1, out, x, z, w, h);


    c_i8 mc = l->mc;
    c_u64 ss = l->startSeed;
    u64 cs;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v;
            c_int idx = i + j * w;
            int id = out[idx];
            c_int hasHighBit = (id & 0xf00);
            id &= ~0xf00;

            if (mc <= MC_1_6) {
                if (id == ocean || id == mushroom_fields) {
                    out[idx] = static_cast<biome_t>(id);
                    continue;
                }

                cs = getChunkSeed(ss, i + x, j + z);

                if (mc <= MC_1_1) v = oldBiomes11[mcFirstInt<6>(cs)];
                else
                    v = oldBiomes[mcFirstInt<7>(cs)];

                if (id != plains && (v != taiga || mc <= MC_1_2)) v = snowy_tundra;
            } else {
                if (isOceanic(static_cast<biome_t>(id)) || id == mushroom_fields) {
                    out[idx] = static_cast<biome_t>(id);
                    continue;
                }

                cs = getChunkSeed(ss, i + x, j + z);

                switch (id) {
                    case warm:
                        if (hasHighBit) v = mcFirstIsZero<3>(cs) ? badlands_plateau : wooded_badlands_plateau;
                        else
                            v = warmBiomes[mcFirstInt<6>(cs)];
                        break;
                    case lush:
                        if (hasHighBit) v = jungle;
                        else
                            v = lushBiomes[mcFirstInt<6>(cs)];
                        break;
                    case cold:
                        if (hasHighBit) v = giant_tree_taiga;
                        else
                            v = coldBiomes[mcFirstInt<4>(cs)];
                        break;
                    case freezing:
                        v = snowBiomes[mcFirstInt<4>(cs)];
                        break;
                    default:
                        v = mushroom_fields;
                }
            }

            out[idx] = v;
        }
    }
}


/**
 * @var mapRiverInit
 * @brief Mapping function for initializing river noise.
 */
void mapRiverInit(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    l->p1->getMap(l->p1, out, x, z, w, h);


    c_u64 ss = l->startSeed;
    c_int mod = (l->mc <= MC_1_6) ? 2 : 299999;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const biome_t var = out[i + j * w];
            if (var != biome_t::ocean && var != biome_t::none) {
                const u64 cs = getChunkSeed(ss, i + x, j + z);
                out[i + j * w] = static_cast<biome_t>(mcFirstInt(cs, mod) + 2);
            } else {
                out[i + j * w] = static_cast<biome_t>(0);
            }
        }
    }
}


/**
 * @var mapBamboo
 * @brief Mapping function for adding bamboo areas.
 *        Previously known as mapAddBamboo.
 */
void mapBamboo(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    l->p1->getMap(l->p1, out, x, z, w, h);


    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            c_int idx = i + j * w;
            if (out[idx] != jungle) continue;

            const u64 cs = getChunkSeed(ss, i + x, j + z);
            if (mcFirstIsZero<10>(cs)) { out[idx] = bamboo_jungle; }
        }
    }
}


static int replaceEdge(biome_t* out, c_int idx, const MCVERSION mc, const biome_t v10, const biome_t v21, const biome_t v01,
                       const biome_t v12, const biome_t id, const biome_t baseID, const biome_t edgeID) {
    if (id != baseID) return 0;

    if (areSimilar(mc, v10, baseID) &&
        areSimilar(mc, v21, baseID) &&
        areSimilar(mc, v01, baseID) &&
        areSimilar(mc, v12, baseID))
        out[idx] = id;
    else
        out[idx] = edgeID;

    return 1;
}


/**
 * @var mapBiomeEdge
 * @brief Mapping function for defining biome edges.
 */
void mapBiomeEdge(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    const MCVERSION mc = l->mc;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        for (int i = 0; i < w; i++) {
            const biome_t v11 = vz1[i + 1];
            const biome_t v10 = vz0[i + 1];
            const biome_t v21 = vz1[i + 2];
            const biome_t v01 = vz1[i + 0];
            const biome_t v12 = vz2[i + 1];

            if (!replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, wooded_badlands_plateau, badlands) &&
                !replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, badlands_plateau, badlands) &&
                !replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, giant_tree_taiga, taiga)) {
                if (v11 == desert) {
                    if (!isAny4(snowy_tundra, v10, v21, v01, v12)) {
                        out[i + j * w] = v11;
                    } else {
                        out[i + j * w] = wooded_mountains;
                    }
                } else if (v11 == swamp) {
                    if (!isAny4(desert, v10, v21, v01, v12) && !isAny4(snowy_taiga, v10, v21, v01, v12) &&
                        !isAny4(snowy_tundra, v10, v21, v01, v12)) {
                        if (!isAny4(jungle, v10, v21, v01, v12) && !isAny4(bamboo_jungle, v10, v21, v01, v12))
                            out[i + j * w] = v11;
                        else
                            out[i + j * w] = jungle_edge;
                    } else {
                        out[i + j * w] = plains;
                    }
                } else {
                    out[i + j * w] = v11;
                }
            }
        }
    }
}


/**
 * @var mapHills
 * @brief Mapping function for adding hills to the layer.
 */
void mapHills(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapHills() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    biome_t* riv = out + pW * pH;
    l->p2->getMap(l->p2, riv, pX, pZ, pW, pH);


    const MCVERSION mc = l->mc;
    c_u64 st = l->startSalt;
    c_u64 ss = l->startSeed;


    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const biome_t a11 = out[i + 1 + (j + 1) * pW]; // biome branch
            const biome_t b11 = riv[i + 1 + (j + 1) * pW]; // river branch
            const int idx = i + j * w;

            // volatile int kill_myself_1 = -1;
            // volatile int kill_myself_2 = 255;
            // if (((kill_myself_1 - 2) % 29) != ((kill_myself_2 - 2) % 29)) {
            //     printf("KILL MYSELF, -1: %d, 255: %d\n",
            //            ((kill_myself_1 - 2) % 29),
            //            ((kill_myself_2 - 2) % 29));
            //     exit(1);
            // }

            int bn = biome_t::none;
            if (mc >= MC_1_7) bn = (b11 - 2) % 29;

            if (bn == 1 && b11 >= 2 && !isShallowOcean(a11)) {
                const biome_t m = getMutated(mc, a11);
                if (m != biome_t::ocean && m != biome_t::none) out[idx] = m;
                else
                    out[idx] = a11;
            } else {
                u64 cs = getChunkSeed(ss, i + x, j + z);
                if (bn == 0 || mcFirstIsZero<3>(cs)) {
                    biome_t hillID = a11;

                    switch (a11) {
                        case desert:
                            hillID = desert_hills;
                            break;
                        case forest:
                            hillID = wooded_hills;
                            break;
                        case birch_forest:
                            hillID = birch_forest_hills;
                            break;
                        case dark_forest:
                            hillID = plains;
                            break;
                        case taiga:
                            hillID = taiga_hills;
                            break;
                        case giant_tree_taiga:
                            hillID = giant_tree_taiga_hills;
                            break;
                        case snowy_taiga:
                            hillID = snowy_taiga_hills;
                            break;
                        case plains:
                            if (mc <= MC_1_6) {
                                hillID = forest;
                                break;
                            }
                            cs = mcStepSeed(cs, st);
                            hillID = mcFirstIsZero<3>(cs) ? wooded_hills : forest;
                            break;
                        case snowy_tundra:
                            hillID = snowy_mountains;
                            break;
                        case jungle:
                            hillID = jungle_hills;
                            break;
                        case bamboo_jungle:
                            hillID = bamboo_jungle_hills;
                            break;
                        case ocean:
                            if (mc >= MC_1_7) hillID = deep_ocean;
                            break;
                        case mountains:
                            if (mc >= MC_1_7) hillID = wooded_mountains;
                            break;
                        case savanna:
                            hillID = savanna_plateau;
                            break;
                        default:
                            if (areSimilar(mc, a11, wooded_badlands_plateau)) hillID = badlands;
                            else if (isDeepOcean(a11)) {
                                cs = mcStepSeed(cs, st);
                                if (mcFirstIsZero<3>(cs)) {
                                    cs = mcStepSeed(cs, st);
                                    hillID = mcFirstIsZero<2>(cs) ? plains : forest;
                                }
                            }
                            break;
                    }

                    if (bn == 0 && hillID != a11) {
                        hillID = getMutated(mc, hillID);
                        if (hillID == biome_t::none) hillID = a11;
                    }

                    if (hillID != a11) {
                        const biome_t a10 = out[i + 1 + (j + 0) * pW];
                        const biome_t a21 = out[i + 2 + (j + 1) * pW];
                        const biome_t a01 = out[i + 0 + (j + 1) * pW];
                        const biome_t a12 = out[i + 1 + (j + 2) * pW];
                        int equals = 0;

                        if (areSimilar(mc, a10, a11)) equals++;
                        if (areSimilar(mc, a21, a11)) equals++;
                        if (areSimilar(mc, a01, a11)) equals++;
                        if (areSimilar(mc, a12, a11)) equals++;

                        if (equals >= 3 + (mc <= MC_1_6)) out[idx] = hillID;
                        else
                            out[idx] = a11;
                    } else {
                        out[idx] = a11;
                    }
                } else {
                    out[idx] = a11;
                }
            }
        }
    }
}


static biome_t reduceID(c_int id) {
    if (id == biome_t::none) return biome_t::none;
    const int v = static_cast<int>(id);
    return static_cast<biome_t>(v >= 2 ? 2 + (v & 1) : v);
}


/**
 * @var mapRiver
 * @brief Mapping function for generating rivers.
 */
void mapRiver(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_i8 mc = l->mc;

    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        for (int i = 0; i < w; i++) {
            biome_t v01 = vz1[i + 0];
            biome_t v11 = vz1[i + 1];
            biome_t v21 = vz1[i + 2];
            biome_t v10 = vz0[i + 1];
            biome_t v12 = vz2[i + 1];

            if (mc >= MC_1_7) {
                v01 = reduceID(v01);
                v11 = reduceID(v11);
                v21 = reduceID(v21);
                v10 = reduceID(v10);
                v12 = reduceID(v12);
            } else if (v11 == 0) {
                out[i + j * w] = river;
                continue;
            }

            if (v11 == v01 && v11 == v10 && v11 == v12 && v11 == v21) {
                out[i + j * w] = biome_t::none;
            } else {
                out[i + j * w] = river;
            }
        }
    }
}


/**
 * @var mapSmooth
 * @brief Mapping function for smoothing transitions between areas.
 */
void mapSmooth(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        for (int i = 0; i < w; i++) {
            biome_t v11 = vz1[i + 1];
            const biome_t v01 = vz1[i + 0];
            const biome_t v10 = vz0[i + 1];

            if (v11 != v01 || v11 != v10) {
                c_int v21 = vz1[i + 2];
                c_int v12 = vz2[i + 1];
                if (v01 == v21 && v10 == v12) {
                    const u64 cs = getChunkSeed(ss, i + x, j + z);
                    if (cs & (1ULL << 24)) v11 = v10;
                    else
                        v11 = v01;
                } else {
                    if (v01 == v21) v11 = v01;
                    if (v10 == v12) v11 = v10;
                }
            }

            out[i + j * w] = v11;
        }
    }
}


/**
 * @var mapSunflower
 * @brief Mapping function for adding rare biomes like sunflower plains.
 *        Previously known as mapRareBiome.
 */
void mapSunflower(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    l->p1->getMap(l->p1, out, x, z, w, h);


    c_u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            c_int v = out[i + j * w];

            if (v == plains) {
                const u64 cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero<57>(cs)) { out[i + j * w] = sunflower_plains; }
            }
        }
    }
}


static int replaceOcean(biome_t* out, c_int idx, const biome_t v10, const biome_t v21, const biome_t v01, const biome_t v12,
                        const biome_t id, const biome_t replaceID) {
    if (isOceanic(id)) return 0;

    if (isOceanic(v10) || isOceanic(v21) || isOceanic(v01) || isOceanic(v12))
        out[idx] = replaceID;
    else
        out[idx] = id;

    return 1;
}

static int isAll4JFTO(const MCVERSION mc, const biome_t a, const biome_t b, const biome_t c, const biome_t d) {
    return (getCategory(mc, a) == jungle || a == forest || a == taiga || isOceanic(a)) &&
           (getCategory(mc, b) == jungle || b == forest || b == taiga || isOceanic(b)) &&
           (getCategory(mc, c) == jungle || c == forest || c == taiga || isOceanic(c)) &&
           (getCategory(mc, d) == jungle || d == forest || d == taiga || isOceanic(d));
}

static int isAny4Oceanic(const biome_t a, const biome_t b, const biome_t c, const biome_t d) {
    return isOceanic(a) || isOceanic(b) || isOceanic(c) || isOceanic(d);
}


/**
 * @var mapShore
 * @brief Mapping function for defining shorelines.
 */
void mapShore(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    const MCVERSION mc = l->mc;

    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        for (int i = 0; i < w; i++) {
            biome_t v11 = vz1[i + 1];
            const biome_t v10 = vz0[i + 1];
            const biome_t v21 = vz1[i + 2];
            const biome_t v01 = vz1[i + 0];
            const biome_t v12 = vz2[i + 1];

            if (v11 == mushroom_fields) {
                if (isAny4(ocean, v10, v21, v01, v12))
                    out[i + j * w] = mushroom_field_shore;
                else
                    out[i + j * w] = v11;
                continue;
            }
            if (mc <= MC_1_0) {
                out[i + j * w] = v11;
                continue;
            }

            if (mc <= MC_1_6) {
                if (v11 == mountains) {
                    if (v10 != mountains || v21 != mountains || v01 != mountains || v12 != mountains)
                        v11 = mountain_edge;
                } else if (v11 != ocean && v11 != river && v11 != swamp) {
                    if (isAny4(ocean, v10, v21, v01, v12)) v11 = beach;
                }
                out[i + j * w] = v11;
            } else if (getCategory(mc, v11) == jungle) {
                if (isAll4JFTO(mc, v10, v21, v01, v12)) {
                    if (isAny4Oceanic(v10, v21, v01, v12)) out[i + j * w] = beach;
                    else
                        out[i + j * w] = v11;
                } else {
                    out[i + j * w] = jungle_edge;
                }
            } else if (v11 == mountains || v11 == wooded_mountains /* || v11 == mountain_edge*/) {
                replaceOcean(out, i + j * w, v10, v21, v01, v12, v11, stone_shore);
            } else if (isSnowy(v11)) {
                replaceOcean(out, i + j * w, v10, v21, v01, v12, v11, snowy_beach);
            } else if (v11 == badlands || v11 == wooded_badlands_plateau) {
                if (!isAny4Oceanic(v10, v21, v01, v12)) {
                    if (isMesa(v10) && isMesa(v21) && isMesa(v01) && isMesa(v12)) out[i + j * w] = v11;
                    else
                        out[i + j * w] = desert;
                } else {
                    out[i + j * w] = v11;
                }
            } else {
                if (v11 != ocean && v11 != deep_ocean && v11 != river && v11 != swamp) {
                    if (isAny4Oceanic(v10, v21, v01, v12)) out[i + j * w] = beach;
                    else
                        out[i + j * w] = v11;
                } else {
                    out[i + j * w] = v11;
                }
            }
        }
    }
}


/**
 * @var mapRiverMix
 * @brief Mapping function for mixing river and land layers.
 */
void mapRiverMix(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapRiverMix() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    l->p1->getMap(l->p1, out, x, z, w, h); // biome chain


    const MCVERSION mc = l->mc;
    c_int len = w * h;
    biome_t* buf = out + len;

    l->p2->getMap(l->p2, buf, x, z, w, h); // rivers



    for (int idx = 0; idx < len; idx++) {
        biome_t v = out[idx];

        if (buf[idx] == river && v != ocean && (mc < MC_1_7 || !isOceanic(v))) {
            if (v == snowy_tundra)
                v = frozen_river;
            else if (v == mushroom_fields || v == mushroom_field_shore)
                v = mushroom_fields;
            else
                v = river;
        }

        out[idx] = v;
    }
}


/**
 * @var mapOceanTemp
 * @brief Mapping function for defining ocean temperature zones.
 */
void mapOceanTemp(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {

    // const PerlinNoise *rnd = (const PerlinNoise*) l->noise;

    const u64 ss = l->startSeed;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            const u64 cs = getChunkSeed(ss, i + x, j + z);

            c_int tmp = mcFirstInt<100>(cs);

            if (tmp < 8)
                out[i + j * w] = warm_ocean;
            else if (tmp < 40)
                out[i + j * w] = lukewarm_ocean;
            else if (tmp < 68)
                out[i + j * w] = ocean;
            else if (tmp < 95)
                out[i + j * w] = cold_ocean;
            else
                out[i + j * w] = frozen_ocean;


            // float tmp = mcFirstInt<100>(cs) / 100.0F;

            // if (tmp < 0.075F)
            //     out[i + j*w] = warm_ocean;
            // else if (tmp < 0.4F)
            //     out[i + j*w] = lukewarm_ocean;
            // else if (tmp < 0.675F)
            //     out[i + j*w] = ocean;
            // else if (tmp < 0.95F)
            //     out[i + j*w] = cold_ocean;
            // else
            //     out[i + j*w] = frozen_ocean;


            // double tmp = samplePerlin(rnd, (i + x) / 8.0, (j + z) / 8.0, 0, 0, 0);

            // if (tmp > 0.4)
            //     out[i + j*w] = warm_ocean;
            // else if (tmp > 0.2)
            //     out[i + j*w] = lukewarm_ocean;
            // else if (tmp < -0.4)
            //     out[i + j*w] = frozen_ocean;
            // else if (tmp < -0.2)
            //     out[i + j*w] = cold_ocean;
            // else
            //     out[i + j*w] = ocean;
        }
    }
}


/**
 * @var mapOceanMix
 * @brief Mapping function for mixing ocean layers.
 */
void mapOceanMix(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    int i, j;

    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapOceanMix() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    l->p2->getMap(l->p2, out, x, z, w, h);


    // determine the minimum required land area: (x+lx0, z+lz0), (lw, lh)
    // (the extra border is only required if there is warm or frozen ocean)
    int lx0 = 0;
    int lx1 = w;
    int lz0 = 0;
    int lz1 = h;

    for (j = 0; j < h; j++) {
        c_int jCenter = (j - 8 > 0 && j + 9 < h);
        for (i = 0; i < w; i++) {
            if (jCenter && i - 8 > 0 && i + 9 < w) continue;
            c_int oceanID = out[i + j * w];
            if (oceanID == warm_ocean || oceanID == frozen_ocean) {
                if (i - 8 < lx0) lx0 = i - 8;
                if (i + 9 > lx1) lx1 = i + 9;
                if (j - 8 < lz0) lz0 = j - 8;
                if (j + 9 > lz1) lz1 = j + 9;
            }
        }
    }

    biome_t* land = out + w * h;
    c_int lw = lx1 - lx0;
    c_int lh = lz1 - lz0;
    l->p1->getMap(l->p1, land, x + lx0, z + lz0, lw, lh);


    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            const biome_t landID = land[(i - lx0) + (j - lz0) * lw];
            biome_t oceanID = out[i + j * w];
            biome_t replaceID = biome_t::ocean;

            if (!isOceanic(landID)) {
                out[i + j * w] = landID;
                continue;
            }

            if (oceanID == warm_ocean) replaceID = lukewarm_ocean;
            if (oceanID == frozen_ocean) replaceID = cold_ocean;
            if (replaceID) {
                for (int ii = -8; ii <= 8; ii += 4) {
                    for (int jj = -8; jj <= 8; jj += 4) {
                        const biome_t id = land[(i + ii - lx0) + (j + jj - lz0) * lw];
                        if (!isOceanic(id)) {
                            out[i + j * w] = replaceID;
                            goto loop_x;
                        }
                    }
                }
            }

            if (landID == deep_ocean) {
                switch (oceanID) {
                    case lukewarm_ocean:
                        oceanID = deep_lukewarm_ocean;
                        break;
                    case ocean:
                        oceanID = deep_ocean;
                        break;
                    case cold_ocean:
                        oceanID = deep_cold_ocean;
                        break;
                    case frozen_ocean:
                        oceanID = deep_frozen_ocean;
                        break;
                    default:
                        break;
                }
            }

            out[i + j * w] = oceanID;

        loop_x:;
        }
    }
}


/**
 * @var mapGMushroom
 * @brief Mapping function for adding giant mushroom areas.
 *        Specific to LCE.
 */
void mapGiantMushroom(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            biome_t v11 = out[i + 1 + (j + 1) * pW];

            if (out[i + 0 + (j + 0) * pW] == mushroom_fields || out[i + 2 + (j + 0) * pW] == mushroom_fields ||
                out[i + 0 + (j + 2) * pW] == mushroom_fields || out[i + 2 + (j + 2) * pW] == mushroom_fields) {
                v11 = mushroom_fields;
            }

            out[i + j * w] = v11;
        }
    }
}


/**
 * @var mapOceanEdge
 * @brief Mapping function for defining ocean edges.
 *        Specific to LCE.
 */
void mapOceanEdge(const Layer* l, biome_t* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;

    l->p1->getMap(l->p1, out, pX, pZ, pW, pH);


    for (int j = 0; j < h; j++) {
        const biome_t* vz0 = out + (j + 0) * pW;
        const biome_t* vz1 = out + (j + 1) * pW;
        const biome_t* vz2 = out + (j + 2) * pW;

        for (int i = 0; i < w; i++) {
            biome_t v11 = vz1[i + 1];
            const biome_t v10 = vz0[i + 1];
            const biome_t v21 = vz1[i + 2];
            const biome_t v01 = vz1[i + 0];
            const biome_t v12 = vz2[i + 1];

            if ((v11 == warm_ocean && isAny4(frozen_ocean, v10, v21, v01, v12)) ||
                (v11 == frozen_ocean && isAny4(warm_ocean, v10, v21, v01, v12))) {
                v11 = ocean;
            }

            out[i + j * w] = v11;
        }
    }
}


MU static void getVoronoiCell(c_u64 sha, c_int a, c_int b, c_int c, int* x, int* y, int* z) {
    u64 s = sha;
    s = mcStepSeed(s, a);
    s = mcStepSeed(s, b);
    s = mcStepSeed(s, c);
    s = mcStepSeed(s, a);
    s = mcStepSeed(s, b);
    s = mcStepSeed(s, c);

    *x = (int)((((s >> 24) & 1023) - 512) * 36);
    s = mcStepSeed(s, sha);
    *y = (int)((((s >> 24) & 1023) - 512) * 36);
    s = mcStepSeed(s, sha);
    *z = (int)((((s >> 24) & 1023) - 512) * 36);
}


/**
 * @var mapVoronoi114
 * @brief Mapping function for the final Voronoi layer at 1:1 scale.
 */
void mapVoronoi114(const Layer* l, biome_t* out, int x, int z, int w, int h) {
    x -= 2;
    z -= 2;
    int pX = x >> 2;
    int pZ = z >> 2;
    int pW = ((x + w) >> 2) - pX + 2;
    int pH = ((z + h) >> 2) - pZ + 2;

    if (l->p1) {
        l->p1->getMap(l->p1, out, pX, pZ, pW, pH);
    }

    int i, j, ii, jj, pi, pj, pix, pjz, i4, j4, mi, mj;
    biome_t v00, v01, v10, v11, v;
    i64 da1, da2, db1, db2, dc1, dc2, dd1, dd2;
    i64 sja, sjb, sjc, sjd, da, db, dc, dd;
    biome_t* buf = out + pW * pH;

    u64 st = l->startSalt;
    u64 ss = l->startSeed;
    u64 cs;

    for (pj = 0; pj < pH - 1; pj++) {
        v00 = out[(pj + 0) * pW];
        v01 = out[(pj + 1) * pW];
        pjz = pZ + pj;
        j4 = ((pjz) << 2) - z;

        for (pi = 0; pi < pW - 1; pi++, v00 = v10, v01 = v11) {
            pix = pX + pi;
            i4 = ((pix) << 2) - x;

            // try to prefetch the relevant rows to help prevent cache misses
            PREFETCH(buf + ((pjz << 2) + 0) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 1) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 2) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 3) * w + pi, 1, 1);

            v10 = out[pi + 1 + (pj + 0) * pW];
            v11 = out[pi + 1 + (pj + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                for (jj = 0; jj < 4; jj++) {
                    j = j4 + jj;
                    if (j < 0 || j >= h) continue;
                    for (ii = 0; ii < 4; ii++) {
                        i = i4 + ii;
                        if (i < 0 || i >= w) continue;
                        buf[j * w + i] = v00;
                    }
                }
                continue;
            }

            cs = getChunkSeed(ss, (pi + pX) << 2, (pj + pZ) << 2);
            da1 = (mcFirstInt<1024>(cs) - 512) * 36;
            cs = mcStepSeed(cs, st);
            da2 = (mcFirstInt<1024>(cs) - 512) * 36;

            cs = getChunkSeed(ss, (pi + pX + 1) << 2, (pj + pZ) << 2);
            db1 = (mcFirstInt<1024>(cs) - 512) * 36 + 40 * 1024;
            cs = mcStepSeed(cs, st);
            db2 = (mcFirstInt<1024>(cs) - 512) * 36;

            cs = getChunkSeed(ss, (pi + pX) << 2, (pj + pZ + 1) << 2);
            dc1 = (mcFirstInt<1024>(cs) - 512) * 36;
            cs = mcStepSeed(cs, st);
            dc2 = (mcFirstInt<1024>(cs) - 512) * 36 + 40 * 1024;

            cs = getChunkSeed(ss, (pi + pX + 1) << 2, (pj + pZ + 1) << 2);
            dd1 = (mcFirstInt<1024>(cs) - 512) * 36 + 40 * 1024;
            cs = mcStepSeed(cs, st);
            dd2 = (mcFirstInt<1024>(cs) - 512) * 36 + 40 * 1024;

            for (jj = 0; jj < 4; jj++) {
                j = j4 + jj;
                if (j < 0 || j >= h) continue;

                mj = 10240 * jj;
                sja = (mj - da2) * (mj - da2);
                sjb = (mj - db2) * (mj - db2);
                sjc = (mj - dc2) * (mj - dc2);
                sjd = (mj - dd2) * (mj - dd2);

                for (ii = 0; ii < 4; ii++) {
                    i = i4 + ii;
                    if (i < 0 || i >= w) continue;

                    mi = 10240 * ii;
                    da = (mi - da1) * (mi - da1) + sja;
                    db = (mi - db1) * (mi - db1) + sjb;
                    dc = (mi - dc1) * (mi - dc1) + sjc;
                    dd = (mi - dd1) * (mi - dd1) + sjd;

                    if EXPECT_FALSE ((da < db) && (da < dc) && (da < dd)) v = v00;
                    else if EXPECT_FALSE ((db < da) && (db < dc) && (db < dd))
                        v = v10;
                    else if EXPECT_FALSE ((dc < da) && (dc < db) && (dc < dd))
                        v = v01;
                    else
                        v = v11;

                    buf[j * w + i] = v;
                }
            }
        }
    }

    memmove(out, buf, w * h * sizeof(*buf));
}
