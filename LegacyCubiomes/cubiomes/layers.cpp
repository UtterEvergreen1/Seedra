
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>


#include "LegacyCubiomes/utils/MathHelper.hpp"
#include "LegacyCubiomes/utils/rng.hpp"
#include "layers.hpp"

#include "biomeID.hpp"
#include "noise.hpp"


//==============================================================================
//                              MC Seed Helpers
//==============================================================================

/**
 * The seed pipeline:
 *
 * getLayerSalt(n)                -> layerSalt (layerStack)
 * layerSalt (layerStack), worldSeed (ws) -> startSalt (st), startSeed (ss)
 * startSeed (ss), coords (x,z)   -> chunkSeed (cs)
 *
 * The chunkSeed alone is enough to generate the first PRNG integer with:
 *   mcFirstInt(cs, mod)
 * subsequent PRNG integers are generated by stepping the chunkSeed forwards,
 * salted with startSalt:
 *   cs_next = mcStepSeed(cs, st)
 */

static u64 mcStepSeed(c_u64 s, c_u64 salt) {
    return s * (s * 6364136223846793005ULL + 1442695040888963407ULL) + salt;
}

static int mcFirstInt(c_u64 s, c_int mod) {
    int ret = (int) (((i64) s >> 24) % mod);
    if (ret < 0) ret += mod;
    return ret;
}

static int mcFirstIsZero(c_u64 s, c_int mod) { return (int) (((i64) s >> 24) % mod) == 0; }

static u64 getChunkSeed(c_u64 ss, c_int x, c_int z) {
    u64 cs = ss + x;
    cs = mcStepSeed(cs, z);
    cs = mcStepSeed(cs, x);
    cs = mcStepSeed(cs, z);
    return cs;
}

static u64 getLayerSalt(c_u64 salt) {
    u64 ls = mcStepSeed(salt, salt);
    ls = mcStepSeed(ls, salt);
    ls = mcStepSeed(ls, salt);
    return ls;
}

static u64 getStartSalt(c_u64 ws, c_u64 ls) {
    u64 st = ws;
    st = mcStepSeed(st, ls);
    st = mcStepSeed(st, ls);
    st = mcStepSeed(st, ls);
    return st;
}

MU static u64 getStartSeed(c_u64 ws, c_u64 ls) {
    u64 ss = ws;
    ss = getStartSalt(ss, ls);
    ss = mcStepSeed(ss, 0);
    return ss;
}

//==============================================================================
// Essentials
//==============================================================================

int biomeExists(c_int mc, c_int id) {
    if (id >= ocean && id <= mountain_edge) return 1;
    if (id >= jungle && id <= jungle_hills) return mc >= MC_1_2;
    if (id >= jungle_edge && id <= badlands_plateau) return mc >= MC_1_7;
    if (id >= small_end_islands && id <= end_barrens) return mc >= MC_1_9;
    if (id >= warm_ocean && id <= deep_frozen_ocean) return mc >= MC_1_13;

    switch (id) {
        case the_void:
            return mc >= MC_1_9;
        case sunflower_plains:
        case desert_lakes:
        case gravelly_mountains:
        case flower_forest:
        case taiga_mountains:
        case swamp_hills:
        case ice_spikes:
        case modified_jungle:
        case modified_jungle_edge:
        case tall_birch_forest:
        case tall_birch_hills:
        case dark_forest_hills:
        case snowy_taiga_mountains:
        case giant_spruce_taiga:
        case giant_spruce_taiga_hills:
        case modified_gravelly_mountains:
        case shattered_savanna:
        case shattered_savanna_plateau:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
            return mc >= MC_1_7;
        case bamboo_jungle:
        case bamboo_jungle_hills:
            return mc >= MC_1_14;
        default:
            return 0;
    }
}

int isOverworld(c_int mc, c_int id) {
    if (!biomeExists(mc, id)) return 0;

    if (id >= small_end_islands && id <= end_barrens) return 0;

    switch (id) {
        case nether_wastes:
        case the_end:
            return 0;
        case frozen_ocean:
            return mc <= MC_1_6 || mc >= MC_1_13;
        case mountain_edge:
            return mc <= MC_1_6;
        case deep_warm_ocean:
        case the_void:
            return 0;
        case tall_birch_hills:
            return mc <= MC_1_8 || mc >= MC_1_11;
        default:
            return 1;
    }
}

int getMutated(c_int mc, c_int id) {
    switch (id) {
        case plains:
            return sunflower_plains;
        case desert:
            return desert_lakes;
        case mountains:
            return gravelly_mountains;
        case forest:
            return flower_forest;
        case taiga:
            return taiga_mountains;
        case swamp:
            return swamp_hills;
        case snowy_tundra:
            return ice_spikes;
        case jungle:
            return modified_jungle;
        case jungle_edge:
            return modified_jungle_edge;
            // emulate MC-98995
        case birch_forest:
            return (mc >= MC_1_9 && mc <= MC_1_10) ? tall_birch_hills : tall_birch_forest;
        case birch_forest_hills:
            return (mc >= MC_1_9 && mc <= MC_1_10) ? none : tall_birch_hills;
        case dark_forest:
            return dark_forest_hills;
        case snowy_taiga:
            return snowy_taiga_mountains;
        case giant_tree_taiga:
            return giant_spruce_taiga;
        case giant_tree_taiga_hills:
            return giant_spruce_taiga_hills;
        case wooded_mountains:
            return modified_gravelly_mountains;
        case savanna:
            return shattered_savanna;
        case savanna_plateau:
            return shattered_savanna_plateau;
        case badlands:
            return eroded_badlands;
        case wooded_badlands_plateau:
            return modified_wooded_badlands_plateau;
        case badlands_plateau:
            return modified_badlands_plateau;
        default:
            return none;
    }
}

int getCategory(int mc, c_int id) {
    switch (id) {
        case beach:
        case snowy_beach:
            return beach;

        case desert:
        case desert_hills:
        case desert_lakes:
            return desert;

        case mountains:
        case mountain_edge:
        case wooded_mountains:
        case gravelly_mountains:
        case modified_gravelly_mountains:
            return mountains;

        case forest:
        case wooded_hills:
        case birch_forest:
        case birch_forest_hills:
        case dark_forest:
        case flower_forest:
        case tall_birch_forest:
        case tall_birch_hills:
        case dark_forest_hills:
            return forest;

        case snowy_tundra:
        case snowy_mountains:
        case ice_spikes:
            return snowy_tundra;

        case jungle:
        case jungle_hills:
        case jungle_edge:
        case modified_jungle:
        case modified_jungle_edge:
        case bamboo_jungle:
        case bamboo_jungle_hills:
            return jungle;

        case badlands:
        case wooded_badlands_plateau:
        case badlands_plateau:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
            return mesa;


        case mushroom_fields:
        case mushroom_field_shore:
            return mushroom_fields;

        case stone_shore:
            return stone_shore;

        case ocean:
        case frozen_ocean:
        case deep_ocean:
        case warm_ocean:
        case lukewarm_ocean:
        case cold_ocean:
        case deep_warm_ocean:
        case deep_lukewarm_ocean:
        case deep_cold_ocean:
        case deep_frozen_ocean:
            return ocean;

        case plains:
        case sunflower_plains:
            return plains;

        case river:
        case frozen_river:
            return river;

        case savanna:
        case savanna_plateau:
        case shattered_savanna:
        case shattered_savanna_plateau:
            return savanna;

        case swamp:
        case swamp_hills:
            return swamp;

        case taiga:
        case taiga_hills:
        case snowy_taiga:
        case snowy_taiga_hills:
        case giant_tree_taiga:
        case giant_tree_taiga_hills:
        case taiga_mountains:
        case snowy_taiga_mountains:
        case giant_spruce_taiga:
        case giant_spruce_taiga_hills:
            return taiga;

        default:
            return none;
    }
}

int areSimilar(c_int mc, c_int id1, c_int id2) {
    if (id1 == id2) return 1;

    if (id1 == wooded_badlands_plateau || id1 == badlands_plateau)
        return id2 == wooded_badlands_plateau || id2 == badlands_plateau;

    return getCategory(mc, id1) == getCategory(mc, id2);
}

int isMesa(c_int id) {
    switch (id) {
        case badlands:
        case eroded_badlands:
        case modified_wooded_badlands_plateau:
        case modified_badlands_plateau:
        case wooded_badlands_plateau:
        case badlands_plateau:
            return 1;
        default:
            return 0;
    }
}

int isShallowOcean(c_int id) {
    constexpr static u64 shallow_bits = (1ULL << ocean) | (1ULL << frozen_ocean) | (1ULL << warm_ocean) |
                                             (1ULL << lukewarm_ocean) | (1ULL << cold_ocean);
    return (u32) id < 64 && ((1ULL << id) & shallow_bits);
}

int isDeepOcean(c_int id) {
    constexpr static u64 deep_bits = (1ULL << deep_ocean) | (1ULL << deep_warm_ocean) |
                                          (1ULL << deep_lukewarm_ocean) | (1ULL << deep_cold_ocean) |
                                          (1ULL << deep_frozen_ocean);
    return (u32) id < 64 && ((1ULL << id) & deep_bits);
}

int isOceanic(c_int id) {
    constexpr static u64 ocean_bits = (1ULL << ocean) | (1ULL << frozen_ocean) | (1ULL << warm_ocean) |
                                           (1ULL << lukewarm_ocean) | (1ULL << cold_ocean) | (1ULL << deep_ocean) |
                                           (1ULL << deep_warm_ocean) | (1ULL << deep_lukewarm_ocean) |
                                           (1ULL << deep_cold_ocean) | (1ULL << deep_frozen_ocean);
    return (u32) id < 64 && ((1ULL << id) & ocean_bits);
}

int isSnowy(c_int id) {
    switch (id) {
        case frozen_ocean:
        case frozen_river:
        case snowy_tundra:
        case snowy_mountains:
        case snowy_beach:
        case snowy_taiga:
        case snowy_taiga_hills:
        case ice_spikes:
        case snowy_taiga_mountains:
            return 1;
        default:
            return 0;
    }
}

void setLayerSeed(Layer* layer, c_u64 worldSeed) {
    if (layer->p2 != nullptr) setLayerSeed(layer->p2, worldSeed);

    if (layer->p != nullptr) setLayerSeed(layer->p, worldSeed);

    c_u64 ls = layer->layerSalt;
    if (ls == 0) { // Pre 1.13 the Hills branch stays zero-initialized
        layer->startSalt = 0;
        layer->startSeed = 0;
    } else {
        u64 st = worldSeed;
        st = mcStepSeed(st, ls);
        st = mcStepSeed(st, ls);
        st = mcStepSeed(st, ls);

        layer->startSalt = st;
        layer->startSeed = mcStepSeed(st, 0);
    }
}


///=============================================================================
/// Layered Biome const Generation (old interface up to 1.17)
///=============================================================================

/* Set up custom layers. */
Layer* setupLayer(Layer* l, mapfunc_t* map, const MCVERSION theMc, c_i8 zoom, c_i8 edge,
                  c_u64 saltBase, Layer* p, Layer* p2) {
    //Layer *l = g->layers + layerId;
    l->getMap = map;
    l->mc = theMc;
    l->zoom = zoom;
    l->edge = edge;
    l->scale = 0;
    if (saltBase == 0) l->layerSalt = saltBase;
    else
        l->layerSalt = getLayerSalt(saltBase);
    l->startSalt = 0;
    l->startSeed = 0;
    l->p = p;
    l->p2 = p2;
    /*
    std::cout
    << (int)l->mc << " "
    << (int)l->zoom << " "
    << (int)l->edge << " "
    << (int)l->scale << " "
    << std::endl;
     */
    // printf("Layer address: %p\n", layer);

    return l;
}

void setupScale(Layer* l, int scale) {
    l->scale = scale;
    if (l->p) setupScale(l->p, scale * l->zoom);
    if (l->p2) setupScale(l->p2, scale * l->zoom);
}

//TODO: BIOMES FOR EARLY VERSIONS (before elytra)
void setupLayerStack(LayerStack* g, const LCEVERSION lceVersion, const lce::BIOMESCALE biomeSize) {

    MCVERSION mc = getMCVersion(lceVersion);
    memset(g, 0, sizeof(LayerStack));
    Layer *p, *l = g->layers;
    // L: layer
    // M: mapping function
    // V: minecraft version
    // Z: zoom
    // E: edge
    // S: salt base
    // P1: parent 1
    // P2: parent 2

    //             L                       M               V   Z  E  S     P1 P2
    p = setupLayer(l + L_CONTINENT_4096, mapContinent, mc, 1, 0, 1, nullptr, nullptr);
    p = setupLayer(l + L_ZOOM_2048, mapZoomFuzzy, mc, 2, 3, 2000, p, nullptr);
    p = setupLayer(l + L_LAND_2048, mapLand, mc, 1, 2, 1, p, nullptr);
    p = setupLayer(l + L_ZOOM_1024, mapZoom, mc, 2, 3, 2001, p, nullptr);
    p = setupLayer(l + L_LAND_1024_A, mapLand, mc, 1, 2, 2, p, nullptr);

    //             L                   M               V   Z  E  S     P1 P2
    p = setupLayer(l + L_LAND_1024_B, mapLand, mc, 1, 2, 50, p, nullptr);
    p = setupLayer(l + L_LAND_1024_C, mapLand, mc, 1, 2, 70, p, nullptr);
    p = setupLayer(l + L_ISLAND_1024, mapIsland, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_SNOW_1024, mapSnow, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_LAND_1024_D, mapLand, mc, 1, 2, 3, p, nullptr);
    p = setupLayer(l + L_COOL_1024, mapCool, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_HEAT_1024, mapHeat, mc, 1, 2, 2, p, nullptr);
    p = setupLayer(l + L_SPECIAL_1024, mapSpecial, mc, 1, 2, 3, p, nullptr);
    p = setupLayer(l + L_ZOOM_512, mapZoom, mc, 2, 3, 2002, p, nullptr);
    p = setupLayer(l + L_ZOOM_256, mapZoom, mc, 2, 3, 2003, p, nullptr);
    p = setupLayer(l + L_LAND_256, mapLand, mc, 1, 2, 4, p, nullptr);
    if (biomeSize != lce::BIOMESCALE::SMALL) p = setupLayer(l + L_MUSHROOM_256, mapMushroom, mc, 1, 2, 5, p, nullptr);
    p = setupLayer(l + L_DEEP_OCEAN_256, mapDeepOcean, mc, 1, 2, 4, p, nullptr);
    p = setupLayer(l + L_BIOME_256, mapBiome, mc, 1, 0, 200, p, nullptr);
    if (mc >= MC_1_14) p = setupLayer(l + L_BAMBOO_256, mapBamboo, mc, 1, 0, 1001, p, nullptr);

    if (biomeSize >= lce::BIOMESCALE::MEDIUM) p = setupLayer(l + L_ZOOM_128, mapZoom, mc, 2, 3, 1000, p, nullptr);
    if (biomeSize >= lce::BIOMESCALE::LARGE) p = setupLayer(l + L_ZOOM_64, mapZoom, mc, 2, 3, 1001, p, nullptr);

    p = setupLayer(l + L_BIOME_EDGE_64, mapBiomeEdge, mc, 1, 2, 1000, p, nullptr);
    // river noise layer chain, also used to determine where hills const generate
    p = setupLayer(l + L_RIVER_INIT_256, mapNoise, mc, 1, 0, 100, l + L_DEEP_OCEAN_256, nullptr);

    // latest WII U has oceans, so I use 1.13 but these salts are 0 so this works like 1.12-
    // if (mc <= MC_1_12)
    // {
    p = setupLayer(l + L_ZOOM_128_HILLS, mapZoom, mc, 2, 3, 0, p, nullptr);
    p = setupLayer(l + L_ZOOM_64_HILLS, mapZoom, mc, 2, 3, 0, p, nullptr);
    // }
    // else if (mc >= MC_1_1)
    // {
    // p = setupLayer(l+L_ZOOM_128_HILLS, mapZoom,        mc, 2, 3, 1000, p, 0);
    // p = setupLayer(l+L_ZOOM_64_HILLS,  mapZoom,        mc, 2, 3, 1001, p, 0);
    // }


    p = setupLayer(l + L_HILLS_64, mapHills, mc, 1, 2, 1000, l + L_BIOME_EDGE_64, l + L_ZOOM_64_HILLS);

    p = setupLayer(l + L_SUNFLOWER_64, mapSunflower, mc, 1, 0, 1001, p, nullptr);

    // for i in 0..biomeScale

    // iteration 0
    p = setupLayer(l + L_ZOOM_32, mapZoom, mc, 2, 3, 1000, p, nullptr);
    p = setupLayer(l + L_LAND_32, mapLand, mc, 1, 2, 3, p, nullptr);
    if (biomeSize == lce::BIOMESCALE::SMALL) p = setupLayer(l + L_A_MUSHROOM_32, mapMushroom, mc, 1, 2, 5, p, nullptr);

    // iteration 1
    p = setupLayer(l + L_ZOOM_16, mapZoom, mc, 2, 3, 1001, p, nullptr);
    if (biomeSize == lce::BIOMESCALE::SMALL) p = setupLayer(l + L_G_MUSHROOM_16, mapGMushroom, mc, 1, 2, 5, p, nullptr);
    p = setupLayer(l + L_SHORE_16, mapShore, mc, 1, 2, 1000, p, nullptr);

    // iteration 2
    p = setupLayer(l + L_ZOOM_8, mapZoom, mc, 2, 3, 1002, p, nullptr);

    // iteration 3
    p = setupLayer(l + L_ZOOM_4, mapZoom, mc, 2, 3, 1003, p, nullptr);
    p = setupLayer(l + L_SMOOTH_4, mapSmooth, mc, 1, 2, 1000, p, nullptr);

    // river layer chain
    p = setupLayer(l + L_ZOOM_128_RIVER, mapZoom, mc, 2, 3, 1000, l + L_RIVER_INIT_256, nullptr);
    p = setupLayer(l + L_ZOOM_64_RIVER, mapZoom, mc, 2, 3, 1001, p, nullptr);
    p = setupLayer(l + L_ZOOM_32_RIVER, mapZoom, mc, 2, 3, 1000, p, nullptr);
    p = setupLayer(l + L_ZOOM_16_RIVER, mapZoom, mc, 2, 3, 1001, p, nullptr);
    p = setupLayer(l + L_ZOOM_8_RIVER, mapZoom, mc, 2, 3, 1002, p, nullptr);
    p = setupLayer(l + L_ZOOM_4_RIVER, mapZoom, mc, 2, 3, 1003, p, nullptr);

    p = setupLayer(l + L_RIVER_4, mapRiver, mc, 1, 2, 1, p, nullptr);
    p = setupLayer(l + L_SMOOTH_4_RIVER, mapSmooth, mc, 1, 2, 1000, p, nullptr);

    p = setupLayer(l + L_RIVER_MIX_4, mapRiverMix, mc, 1, 0, 100, l + L_SMOOTH_4, l + L_SMOOTH_4_RIVER);

    c_int hasOceans = mc >= MCVERSION::MC_1_13;

    if (hasOceans) {
        // ocean variants
        p = setupLayer(l + L_OCEAN_TEMP_256, mapOceanTemp, mc, 1, 0, 2, nullptr, nullptr);
        // p->noise = &g->oceanRnd;
        p = setupLayer(l + L_OCEAN_EDGE_256, mapOceanEdge, mc, 1, 1, 2, p, nullptr);
        p = setupLayer(l + L_ZOOM_128_OCEAN, mapZoom, mc, 2, 3, 2001, p, nullptr);
        p = setupLayer(l + L_ZOOM_64_OCEAN, mapZoom, mc, 2, 3, 2002, p, nullptr);
        p = setupLayer(l + L_ZOOM_32_OCEAN, mapZoom, mc, 2, 3, 2003, p, nullptr);
        p = setupLayer(l + L_ZOOM_16_OCEAN, mapZoom, mc, 2, 3, 2004, p, nullptr);
        p = setupLayer(l + L_ZOOM_8_OCEAN, mapZoom, mc, 2, 3, 2005, p, nullptr);
        p = setupLayer(l + L_ZOOM_4_OCEAN, mapZoom, mc, 2, 3, 2006, p, nullptr);
        p = setupLayer(l + L_OCEAN_MIX_4, mapOceanMix, mc, 1, 17, 100, l + L_RIVER_MIX_4, l + L_ZOOM_4_OCEAN);
    }

    p = setupLayer(l + L_VORONOI_1, mapVoronoi114, mc, 4, 3, 10, p, nullptr);

    g->entry_1 = p;
    g->entry_4 = l + (!hasOceans ? L_RIVER_MIX_4 : L_OCEAN_MIX_4);
    if (mc >= MC_1_1) {
        g->entry_16 = l + (mc <= MC_1_6 ? L_SWAMP_RIVER_16 : L_SHORE_16);
        g->entry_64 = l + (mc <= MC_1_7 ? L_HILLS_64 : L_SUNFLOWER_64);
        g->entry_256 = l + (mc <= MC_1_14 ? L_BIOME_256 : L_BAMBOO_256);
    } else {
        g->entry_16 = l + L_ZOOM_16;
        g->entry_64 = l + L_ZOOM_64;
        g->entry_256 = l + L_BIOME_256;
    }
    setupScale(g->entry_1, 1);
}


int getBiomeDepthAndScale(int id, double* depth, double* scale, int* grass) {
    constexpr int dh = 62; // default height
    double s, d, g;
    switch (id) {
        case ocean:
            s = 0.100;
            d = -1.000;
            g = dh;
            break;
        case plains:
            s = 0.050;
            d = 0.125;
            g = dh;
            break;
        case desert:
            s = 0.050;
            d = 0.125;
            g = 0;
            break;
        case mountains:
            s = 0.500;
            d = 1.000;
            g = dh;
            break;
        case forest:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case taiga:
            s = 0.200;
            d = 0.200;
            g = dh;
            break;
        case swamp:
            s = 0.100;
            d = -0.200;
            g = dh;
            break;
        case river:
            s = 0.000;
            d = -0.500;
            g = 60;
            break;
        case frozen_ocean:
            s = 0.100;
            d = -1.000;
            g = dh;
            break;
        case frozen_river:
            s = 0.000;
            d = -0.500;
            g = 60;
            break;
        case snowy_tundra:
            s = 0.050;
            d = 0.125;
            g = dh;
            break;
        case snowy_mountains:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case mushroom_fields:
            s = 0.300;
            d = 0.200;
            g = 0;
            break;
        case mushroom_field_shore:
            s = 0.025;
            d = 0.000;
            g = 0;
            break;
        case beach:
            s = 0.025;
            d = 0.000;
            g = 64;
            break;
        case desert_hills:
            s = 0.300;
            d = 0.450;
            g = 0;
            break;
        case wooded_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case taiga_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case mountain_edge:
            s = 0.300;
            d = 0.800;
            g = dh;
            break;
        case jungle:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case jungle_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case jungle_edge:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case deep_ocean:
            s = 0.100;
            d = -1.800;
            g = dh;
            break;
        case stone_shore:
            s = 0.800;
            d = 0.100;
            g = 64;
            break;
        case snowy_beach:
            s = 0.025;
            d = 0.000;
            g = 64;
            break;
        case birch_forest:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case birch_forest_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case dark_forest:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case snowy_taiga:
            s = 0.200;
            d = 0.200;
            g = dh;
            break;
        case snowy_taiga_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case giant_tree_taiga:
            s = 0.200;
            d = 0.200;
            g = dh;
            break;
        case giant_tree_taiga_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        case wooded_mountains:
            s = 0.500;
            d = 1.000;
            g = dh;
            break;
        case savanna:
            s = 0.050;
            d = 0.125;
            g = dh;
            break;
        case savanna_plateau:
            s = 0.025;
            d = 1.500;
            g = dh;
            break;
        case badlands:
            s = 0.200;
            d = 0.100;
            g = 0;
            break;
        case wooded_badlands_plateau:
            s = 0.025;
            d = 1.500;
            g = 0;
            break;
        case badlands_plateau:
            s = 0.025;
            d = 1.500;
            g = 0;
            break;
        case warm_ocean:
            s = 0.100;
            d = -1.000;
            g = 0;
            break;
        case lukewarm_ocean:
            s = 0.100;
            d = -1.000;
            g = dh;
            break;
        case cold_ocean:
            s = 0.100;
            d = -1.000;
            g = dh;
            break;
        case deep_warm_ocean:
            s = 0.100;
            d = -1.800;
            g = 0;
            break;
        case deep_lukewarm_ocean:
            s = 0.100;
            d = -1.800;
            g = dh;
            break;
        case deep_cold_ocean:
            s = 0.100;
            d = -1.800;
            g = dh;
            break;
        case deep_frozen_ocean:
            s = 0.100;
            d = -1.800;
            g = dh;
            break;
        case sunflower_plains:
            s = 0.050;
            d = 0.125;
            g = dh;
            break;
        case desert_lakes:
            s = 0.250;
            d = 0.225;
            g = 0;
            break;
        case gravelly_mountains:
            s = 0.500;
            d = 1.000;
            g = dh;
            break;
        case flower_forest:
            s = 0.400;
            d = 0.100;
            g = dh;
            break;
        case taiga_mountains:
            s = 0.400;
            d = 0.300;
            g = dh;
            break;
        case swamp_hills:
            s = 0.300;
            d = -0.100;
            g = dh;
            break;
        case ice_spikes:
            s = 0.450;
            d = 0.425;
            g = 0;
            break;
        case modified_jungle:
            s = 0.400;
            d = 0.200;
            g = dh;
            break;
        case modified_jungle_edge:
            s = 0.400;
            d = 0.200;
            g = dh;
            break;
        case tall_birch_forest:
            s = 0.400;
            d = 0.200;
            g = dh;
            break;
        case tall_birch_hills:
            s = 0.500;
            d = 0.550;
            g = dh;
            break;
        case dark_forest_hills:
            s = 0.400;
            d = 0.200;
            g = dh;
            break;
        case snowy_taiga_mountains:
            s = 0.400;
            d = 0.300;
            g = dh;
            break;
        case giant_spruce_taiga:
            s = 0.200;
            d = 0.200;
            g = dh;
            break;
        case giant_spruce_taiga_hills:
            s = 0.200;
            d = 0.200;
            g = dh;
            break;
        case modified_gravelly_mountains:
            s = 0.500;
            d = 1.000;
            g = dh;
            break;
        case shattered_savanna:
            s = 1.225;
            d = 0.3625;
            g = dh;
            break;
        case shattered_savanna_plateau:
            s = 1.212;
            d = 1.050;
            g = dh;
            break;
        case eroded_badlands:
            s = 0.200;
            d = 0.100;
            g = 0;
            break;
        case modified_wooded_badlands_plateau:
            s = 0.300;
            d = 0.450;
            g = 0;
            break;
        case modified_badlands_plateau:
            s = 0.300;
            d = 0.450;
            g = 0;
            break;
        case bamboo_jungle:
            s = 0.200;
            d = 0.100;
            g = dh;
            break;
        case bamboo_jungle_hills:
            s = 0.300;
            d = 0.450;
            g = dh;
            break;
        default:
            return 0;
    }
    if (scale) *scale = s;
    if (depth) *depth = d;
    if (grass) *grass = g;
    return 1;
}


/* Recursively calculates the minimum buffer size required to const generate an area
 * of the specified size from the current layer onwards.
 */
void getMaxArea(const Layer* layer, int areaX, int areaZ, int* maxX, int* maxZ, size_t* siz) {
    if (layer == nullptr) return;

    // printf("edge: %d\n", layer->edge);

    areaX += layer->edge;
    areaZ += layer->edge;

    if (areaX > *maxX) *maxX = areaX;
    if (areaZ > *maxZ) *maxZ = areaZ;

    if (layer->zoom == 2) {
        areaX >>= 1;
        areaZ >>= 1;
    } else if (layer->zoom == 4) {
        areaX >>= 2;
        areaZ >>= 2;
    }

    // multi-layers and zoom-layers use a temporary copy of their parent area
    if (layer->p2 || layer->zoom != 1) *siz += areaX * areaZ;

    getMaxArea(layer->p, areaX, areaZ, maxX, maxZ, siz);
    if (layer->p2) getMaxArea(layer->p2, areaX, areaZ, maxX, maxZ, siz);
}

size_t getMinLayerCacheSize(const Layer* layer, c_int sizeX, int const sizeZ) {
    int maxX = sizeX;
    int maxZ = sizeZ;
    size_t bufferSize = 0;
    getMaxArea(layer, sizeX, sizeZ, &maxX, &maxZ, &bufferSize);
    return bufferSize + maxX * static_cast<size_t>(maxZ);
}

/** const Generates the specified area using the current const generator settings and stores
 * the biomeIDs in 'out'.
 * The biomeIDs will be indexed in the form: out[x + z*areaWidth]
 * It is recommended that 'out' is allocated using allocCache() for the correct
 * buffer size.
 */
int genArea(const Layer* layer, int* out, c_int areaX, c_int areaZ, c_int areaWidth, c_int areaHeight) {
    // TODO: this could be calloc because it's initializing to 0
    memset(out, 0, areaWidth * areaHeight * sizeof(*out));
    return layer->getMap(layer, out, areaX, areaZ, areaWidth, areaHeight);
}


//==============================================================================
// Noise
//==============================================================================


void initSurfaceNoiseOld(SurfaceNoise* rnd, RNG& seed, double xzScale, double yScale, double xzFactor, double yFactor) {
    rnd->xzScale = xzScale;
    rnd->yScale = yScale;
    rnd->xzFactor = xzFactor;
    rnd->yFactor = yFactor;
    octaveInit(&rnd->octaveMin, seed, rnd->oct + 0, -15, 16);
    octaveInit(&rnd->octaveMax, seed, rnd->oct + 16, -15, 16);
    octaveInit(&rnd->octaveMain, seed, rnd->oct + 32, -7, 8);
}

void initSurfaceNoiseEnd(SurfaceNoise* rnd, c_u64 seed) {
    RNG rng;
    rng.setSeed(seed);
    initSurfaceNoiseOld(rnd, rng, 2.0, 1.0, 80.0, 160.0);
}

double sampleSurfaceNoise(const Generator* g, const SurfaceNoise* rnd, int x, int y, int z) {
    c_double xzScale = 684.412 * rnd->xzScale;
    c_double yScale = 684.412 * rnd->yScale;
    c_double xzStep = xzScale / rnd->xzFactor;
    c_double yStep = yScale / rnd->yFactor;

    double minNoise = 0;
    double maxNoise = 0;
    double mainNoise = 0;
    double persist = 1.0;
    double dx, dy, dz, sy, ty;

    for (int i = 0; i < 16; i++) {
        dx = maintainPrecision(x * xzScale * persist);
        dy = maintainPrecision(y * yScale * persist);
        dz = maintainPrecision(z * xzScale * persist);
        sy = yScale * persist;
        ty = y * sy;

        minNoise += samplePerlin(g, &rnd->octaveMin.octaves[i], dx, dy, dz, sy, ty) / persist;
        maxNoise += samplePerlin(g, &rnd->octaveMax.octaves[i], dx, dy, dz, sy, ty) / persist;

        if (i < 8) {
            dx = maintainPrecision(x * xzStep * persist);
            dy = maintainPrecision(y * yStep * persist);
            dz = maintainPrecision(z * xzStep * persist);
            sy = yStep * persist;
            ty = y * sy;
            mainNoise += samplePerlin(g, &rnd->octaveMain.octaves[i], dx, dy, dz, sy, ty) / persist;
        }
        persist /= 2.0;
    }

    return MathHelper::clampedLerp(0.5 + 0.05 * mainNoise, minNoise / 512.0, maxNoise / 512.0);
}

//==============================================================================
// End const Generation
//==============================================================================

void setEndSeed(EndNoise* en, u64 seed) {
    RNG rng;
    rng.setSeed(seed);
    rng.advance<17292>();
    perlinInit(en, rng);
}


float getEndHeightNoise(const EndNoise* en, int x, int z) {
    c_int hx = x / 2;
    c_int hz = z / 2;
    c_int oddX = x % 2;
    c_int oddZ = z % 2;
    int i, j;

    i64 h = 64 * (x * (i64) x + z * (i64) z);

    for (j = -12; j <= 12; j++) {
        for (i = -12; i <= 12; i++) {
            i64 rx = hx + i;
            i64 rz = hz + j;
            u16 v = 0;
            if (rx * rx + rz * rz > 4096 && sampleSimplex2D(en, (double) rx, (double) rz) < -0.9f) {
                v = (llabs(rx) * 3439 + llabs(rz) * 147) % 13 + 9;
                rx = (oddX - i * 2);
                rz = (oddZ - j * 2);
                c_i64 noise = (rx * rx + rz * rz) * v * v;
                if (noise < h) h = noise;
            }
        }
    }

    float ret = 100 - sqrtf((float) h);
    if (ret < -100) ret = -100;
    if (ret > 80) ret = 80;
    return ret;
}


void sampleNoiseColumnEnd(const Generator* g, double column[], const SurfaceNoise* sn, const EndNoise* en, c_int x,
                          c_int z, c_int colymin, c_int colymax) {
    c_double depth = getEndHeightNoise(en, x, z) - 8.0f;
    for (int y = colymin; y <= colymax; y++) {
        double noise = sampleSurfaceNoise(g, sn, x, y, z);
        noise += depth; // falloff for the End is just the depth
        // clamp top and bottom slides from End settings
        noise = MathHelper::clampedLerp((32 + 46 - y) / 64.0, -3000, noise);
        noise = MathHelper::clampedLerp((y - 1) / 7.0, -30, noise);
        column[y - colymin] = noise;
    }
}


/**
 * Given bordering noise columns and a fractional position between those,
 * determine the surface block height (i.e. where the interpolated noise > 0).
 * Note that the noise columns should be of size: ncolxz[ colymax-colymin+1 ]
 */
int getSurfaceHeight(c_double ncol00[], c_double ncol01[], c_double ncol10[], c_double ncol11[],
                     c_int colymin, c_int colymax, c_int blockspercell, c_double dx, c_double dz) {
    int y, celly;
    for (celly = colymax - 1; celly >= colymin; celly--) {
        c_int idx = celly - colymin;
        c_double v000 = ncol00[idx];
        c_double v001 = ncol01[idx];
        c_double v100 = ncol10[idx];
        c_double v101 = ncol11[idx];
        c_double v010 = ncol00[idx + 1];
        c_double v011 = ncol01[idx + 1];
        c_double v110 = ncol10[idx + 1];
        c_double v111 = ncol11[idx + 1];

        for (y = blockspercell - 1; y >= 0; y--) {
            double dy = y / (double) blockspercell;
            double noise = MathHelper::lerp3D(dy, dx, dz, // Note: not x, y, z
                                              v000, v010, v100, v110, v001, v011, v101, v111);
            if (noise > 0) return celly * blockspercell + y;
        }
    }

    return 0;
}


int getSurfaceHeightEnd(const Generator* g, c_int mc, c_u64 seed, c_int x, c_int z) {
    (void) mc;

    EndNoise en;
    setEndSeed(&en, seed);

    SurfaceNoise sn;
    initSurfaceNoiseEnd(&sn, seed);

    // end noise columns vary on a grid of cell size = eight
    c_int cellX = (x >> 3);
    c_int cellY = (z >> 3);
    c_double dx = (x & 7) / 8.0;
    c_double dz = (z & 7) / 8.0;

    c_int y0 = 0, y1 = 32, yn = y1 - y0 + 1;
    double ncol00[yn];
    double ncol01[yn];
    double ncol10[yn];
    double ncol11[yn];
    sampleNoiseColumnEnd(g, ncol00, &sn, &en, cellX, cellY, y0, y1);
    sampleNoiseColumnEnd(g, ncol01, &sn, &en, cellX, cellY + 1, y0, y1);
    sampleNoiseColumnEnd(g, ncol10, &sn, &en, cellX + 1, cellY, y0, y1);
    sampleNoiseColumnEnd(g, ncol11, &sn, &en, cellX + 1, cellY + 1, y0, y1);

    return getSurfaceHeight(ncol00, ncol01, ncol10, ncol11, y0, y1, 4, dx, dz);
}


//==============================================================================
// Layers
//==============================================================================

// convenience function used in several layers
static int isAny4(c_int id, c_int a, c_int b, c_int c, c_int d) {
    return id == a || id == b || id == c || id == d;
}


int mapContinent(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_u64 ss = l->startSeed;
    u64 cs;
    int i, j;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            cs = getChunkSeed(ss, i + x, j + z);
            out[i + j * w] = mcFirstIsZero(cs, 10);
        }
    }

    if (x > -w && x <= 0 && z > -h && z <= 0) { out[-x + -z * w] = 1; }

    return 0;
}

int mapZoomFuzzy(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x >> 1;
    c_int pZ = z >> 1;
    c_int pW = ((x + w) >> 1) - pX + 1;
    c_int pH = ((z + h) >> 1) - pZ + 1;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_int newW = (pW) << 1;
    //int newH = (pH) << 1;
    int idx, v00, v01, v10, v11;
    int* buf = out + pW * pH; //(int*) malloc((newW+1)*(newH+1)*sizeof(*buf));

    c_auto st = (u32) l->startSalt;
    c_auto ss = (u32) l->startSeed;

    for (j = 0; j < pH; j++) {
        idx = (j << 1) * newW;

        v00 = out[(j + 0) * pW];
        v01 = out[(j + 1) * pW];

        for (i = 0; i < pW; i++, v00 = v10, v01 = v11) {
            v10 = out[i + 1 + (j + 0) * pW];
            v11 = out[i + 1 + (j + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                buf[idx] = v00;
                buf[idx + 1] = v00;
                buf[idx + newW] = v00;
                buf[idx + newW + 1] = v00;
                idx += 2;
                continue;
            }

            c_int chunkX = (int) ((u32) (i + pX) << 1);
            c_int chunkZ = (int) ((u32) (j + pZ) << 1);

            u32 cs = ss;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;

            buf[idx] = v00;
            buf[idx + newW] = (cs >> 24) & 1 ? v01 : v00;
            idx++;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            buf[idx] = (cs >> 24) & 1 ? v10 : v00;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            int r = (cs >> 24) & 3;
            buf[idx + newW] = r == 0 ? v00 : r == 1 ? v10 : r == 2 ? v01 : v11;
            idx++;
        }
    }

    for (j = 0; j < h; j++) { memmove(&out[j * w], &buf[(j + (z & 1)) * newW + (x & 1)], w * sizeof(int)); }
    //free(buf);

    return 0;
}


static int select4(u32 cs, c_u32 st, c_int v00, c_int v01, c_int v10, c_int v11) {
    int v;
    int cv00 = (v00 == v10) + (v00 == v01) + (v00 == v11);
    int cv10 = (v10 == v01) + (v10 == v11);
    int cv01 = (v01 == v11);
    if (cv00 > cv10 && cv00 > cv01) {
        v = v00;
    } else if (cv10 > cv00) {
        v = v10;
    } else if (cv01 > cv00) {
        v = v01;
    } else {
        cs *= cs * 1284865837 + 4150755663;
        cs += st;
        int r = (cs >> 24) & 3;
        v = r == 0 ? v00 : r == 1 ? v10 : r == 2 ? v01 : v11;
    }
    return v;
}

/// This is the most common layer, and generally the second most performance
/// critical after mapAddIsland.
int mapZoom(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x >> 1;
    c_int pZ = z >> 1;
    c_int pW = ((x + w) >> 1) - pX + 1; // (w >> 1) + 2;
    c_int pH = ((z + h) >> 1) - pZ + 1; // (h >> 1) + 2;
    int i, j;

    int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    int newW = (pW) << 1;
    //int newH = (pH) << 1;
    int idx, v00, v01, v10, v11;
    int* buf = out + pW * pH; // (int*) malloc((newW+1)*(newH+1)*sizeof(*buf));

    c_auto st = (u32) l->startSalt;
    c_auto ss = (u32) l->startSeed;

    for (j = 0; j < pH; j++) {
        idx = (j << 1) * newW;

        v00 = out[(j + 0) * pW];
        v01 = out[(j + 1) * pW];

        for (i = 0; i < pW; i++, v00 = v10, v01 = v11) {
            v10 = out[i + 1 + (j + 0) * pW];
            v11 = out[i + 1 + (j + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                buf[idx] = v00;
                buf[idx + 1] = v00;
                buf[idx + newW] = v00;
                buf[idx + newW + 1] = v00;
                idx += 2;
                continue;
            }

            c_int chunkX = (int) ((u32) (i + pX) << 1);
            c_int chunkZ = (int) ((u32) (j + pZ) << 1);

            u32 cs = ss;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkX;
            cs *= cs * 1284865837 + 4150755663;
            cs += chunkZ;

            buf[idx] = v00;
            buf[idx + newW] = (cs >> 24) & 1 ? v01 : v00;
            // buf[idx + newW] = v00 + ((cs >> 24) & 1) * (v01 - v00);
            idx++;

            cs *= cs * 1284865837 + 4150755663;
            cs += st;
            buf[idx] = (cs >> 24) & 1 ? v10 : v00;

            buf[idx + newW] = select4(cs, st, v00, v01, v10, v11);

            idx++;
        }
    }

    for (j = 0; j < h; j++) { memmove(&out[j * w], &buf[(j + (z & 1)) * newW + (x & 1)], w * sizeof(int)); }
    //free(buf);

    return 0;
}

/// This is the most performance critical layer, especially for getBiomeAtPos.
int mapLand(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    u64 st = l->startSalt;
    u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        c_int* vz0 = out + (j + 0) * pW;
        c_int* vz1 = out + (j + 1) * pW;
        c_int* vz2 = out + (j + 2) * pW;

        int v00 = vz0[0], vt0 = vz0[1];
        int v02 = vz2[0], vt2 = vz2[1];
        int v20, v22;
        int v11, v;

        for (i = 0; i < w; i++) {
            v11 = vz1[i + 1];
            v20 = vz0[i + 2];
            v22 = vz2[i + 2];
            v = v11;

            switch (v11) {
                case ocean:
                    if (v00 || v20 || v02 || v22) { // corners have non-ocean
                        /*
                        setChunkSeed(l,x+i,z+j);
                        int inc = 1;
                        if(v00 != 0 && mcNextInt(l,inc++) == 0) v = v00;
                        if(v20 != 0 && mcNextInt(l,inc++) == 0) v = v20;
                        if(v02 != 0 && mcNextInt(l,inc++) == 0) v = v02;
                        if(v22 != 0 && mcNextInt(l,inc++) == 0) v = v22;
                        if(mcNextInt(l,3) == 0) out[x + z*areaWidth] = v;
                        else if(v == 4)         out[x + z*areaWidth] = 4;
                        else                    out[x + z*areaWidth] = 0;
                        */

                        cs = getChunkSeed(ss, i + x, j + z);
                        int inc = 0;
                        v = 1;

                        if (v00 != ocean) {
                            ++inc;
                            v = v00;
                            cs = mcStepSeed(cs, st);
                        }
                        if (v20 != ocean) {
                            if (++inc == 1 || mcFirstIsZero(cs, 2)) v = v20;
                            cs = mcStepSeed(cs, st);
                        }
                        if (v02 != ocean) {
                            switch (++inc) {
                                case 1:
                                    v = v02;
                                    break;
                                case 2:
                                    if (mcFirstIsZero(cs, 2)) v = v02;
                                    break;
                                default:
                                    if (mcFirstIsZero(cs, 3)) v = v02;
                            }
                            cs = mcStepSeed(cs, st);
                        }
                        if (v22 != ocean) {
                            switch (++inc) {
                                case 1:
                                    v = v22;
                                    break;
                                case 2:
                                    if (mcFirstIsZero(cs, 2)) v = v22;
                                    break;
                                case 3:
                                    if (mcFirstIsZero(cs, 3)) v = v22;
                                    break;
                                default:
                                    if (mcFirstIsZero(cs, 4)) v = v22;
                            }
                            cs = mcStepSeed(cs, st);
                        }

                        if (v != forest) {
                            if (!mcFirstIsZero(cs, 3)) v = ocean;
                        }
                    }
                    break;

                case forest:
                    break;

                default:
                    if (v00 == 0 || v20 == 0 || v02 == 0 || v22 == 0) {
                        cs = getChunkSeed(ss, i + x, j + z);
                        if (mcFirstIsZero(cs, 5)) v = 0;
                    }
            }

            out[i + j * w] = v;
            v00 = vt0;
            vt0 = v20;
            v02 = vt2;
            vt2 = v22;
        }
    }

    return 0;
}


int mapIsland(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];
            out[i + j * w] = v11;

            if (v11 == Oceanic) {
                if (out[i + 1 + (j + 0) * pW] != Oceanic) continue;
                if (out[i + 2 + (j + 1) * pW] != Oceanic) continue;
                if (out[i + 0 + (j + 1) * pW] != Oceanic) continue;
                if (out[i + 1 + (j + 2) * pW] != Oceanic) continue;

                cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero(cs, 2)) { out[i + j * w] = 1; }
            }
        }
    }

    return 0;
}

int mapSnow(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];

            if (isShallowOcean(v11)) {
                out[i + j * w] = v11;
            } else {
                cs = getChunkSeed(ss, i + x, j + z);
                int r = mcFirstInt(cs, 6);
                int v;

                if (r == 0) v = Freezing;
                else if (r <= 1)
                    v = Cold;
                else
                    v = Warm;
                // u8 temps[] = {Freezing, Cold, Warm, Warm, Warm, Warm};
                // v = temps[mcFirstInt(cs, 6)];

                out[i + j * w] = v;
            }
        }
    }

    return 0;
}


int mapCool(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];

            if (v11 == Warm) {
                int v10 = out[i + 1 + (j + 0) * pW];
                int v21 = out[i + 2 + (j + 1) * pW];
                int v01 = out[i + 0 + (j + 1) * pW];
                int v12 = out[i + 1 + (j + 2) * pW];

                if (isAny4(Cold, v10, v21, v01, v12) || isAny4(Freezing, v10, v21, v01, v12)) { v11 = Lush; }
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


int mapHeat(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];

            if (v11 == Freezing) {
                int v10 = out[i + 1 + (j + 0) * pW];
                int v21 = out[i + 2 + (j + 1) * pW];
                int v01 = out[i + 0 + (j + 1) * pW];
                int v12 = out[i + 1 + (j + 2) * pW];

                if (isAny4(Warm, v10, v21, v01, v12) || isAny4(Lush, v10, v21, v01, v12)) { v11 = Cold; }
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


int mapSpecial(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int err = l->p->getMap(l->p, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    u64 st = l->startSalt;
    u64 ss = l->startSeed;
    u64 cs;

    int i, j;
    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v = out[i + j * w];
            if (v == 0) continue;

            cs = getChunkSeed(ss, i + x, j + z);

            if (mcFirstIsZero(cs, 13)) {
                cs = mcStepSeed(cs, st);
                v |= (1 + mcFirstInt(cs, 15)) << 8 & 0xf00;
                // 1 to 1 mapping so 'out' can be overwritten immediately
                out[i + j * w] = v;
            }
        }
    }

    return 0;
}


int mapMushroom(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;


    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];

            // surrounded by ocean?
            if (v11 == 0 && !out[i + 0 + (j + 0) * pW] && !out[i + 2 + (j + 0) * pW] && !out[i + 0 + (j + 2) * pW] &&
                !out[i + 2 + (j + 2) * pW]) {
                cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero(cs, 100)) v11 = mushroom_fields;
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


int mapDeepOcean(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[(i + 1) + (j + 1) * pW];

            if (isShallowOcean(v11)) {
                // count adjacent oceans
                int oceans = 0;
                if (isShallowOcean(out[(i + 1) + (j + 0) * pW])) oceans++;
                if (isShallowOcean(out[(i + 2) + (j + 1) * pW])) oceans++;
                if (isShallowOcean(out[(i + 0) + (j + 1) * pW])) oceans++;
                if (isShallowOcean(out[(i + 1) + (j + 2) * pW])) oceans++;

                if (oceans >= 4) {
                    switch (v11) {
                        case warm_ocean:
                            v11 = deep_warm_ocean;
                            break;
                        case lukewarm_ocean:
                            v11 = deep_lukewarm_ocean;
                            break;
                        case ocean:
                            v11 = deep_ocean;
                            break;
                        case cold_ocean:
                            v11 = deep_cold_ocean;
                            break;
                        case frozen_ocean:
                            v11 = deep_frozen_ocean;
                            break;
                        default:
                            v11 = deep_ocean;
                    }
                }
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


constexpr int warmBiomes[] = {desert, desert, desert, savanna, savanna, plains};
constexpr int lushBiomes[] = {forest, dark_forest, mountains, plains, birch_forest, swamp};
constexpr int coldBiomes[] = {forest, mountains, taiga, plains};
constexpr int snowBiomes[] = {snowy_tundra, snowy_tundra, snowy_tundra, snowy_taiga};

constexpr int oldBiomes[] = {desert, forest, mountains, swamp, plains, taiga, jungle};
constexpr int oldBiomes11[] = {desert, forest, mountains, swamp, plains, taiga};
//c_int lushBiomesBE[] = {forest, dark_forest, mountains, plains, plains, plains, birch_forest, swamp};

int mapBiome(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int err = l->p->getMap(l->p, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    c_i8 mc = l->mc;
    c_u64 ss = l->startSeed;
    u64 cs;

    int i, j;
    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v;
            int idx = i + j * w;
            int id = out[idx];
            int hasHighBit = (id & 0xf00);
            id &= ~0xf00;

            if (mc <= MC_1_6) {
                if (id == ocean || id == mushroom_fields) {
                    out[idx] = id;
                    continue;
                }

                cs = getChunkSeed(ss, i + x, j + z);

                if (mc <= MC_1_1) v = oldBiomes11[mcFirstInt(cs, 6)];
                else
                    v = oldBiomes[mcFirstInt(cs, 7)];

                if (id != plains && (v != taiga || mc <= MC_1_2)) v = snowy_tundra;
            } else {
                if (isOceanic(id) || id == mushroom_fields) {
                    out[idx] = id;
                    continue;
                }

                cs = getChunkSeed(ss, i + x, j + z);

                switch (id) {
                    case Warm:
                        if (hasHighBit) v = mcFirstIsZero(cs, 3) ? badlands_plateau : wooded_badlands_plateau;
                        else
                            v = warmBiomes[mcFirstInt(cs, 6)];
                        break;
                    case Lush:
                        if (hasHighBit) v = jungle;
                        else
                            v = lushBiomes[mcFirstInt(cs, 6)];
                        break;
                    case Cold:
                        if (hasHighBit) v = giant_tree_taiga;
                        else
                            v = coldBiomes[mcFirstInt(cs, 4)];
                        break;
                    case Freezing:
                        v = snowBiomes[mcFirstInt(cs, 4)];
                        break;
                    default:
                        v = mushroom_fields;
                }
            }

            out[idx] = v;
        }
    }

    return 0;
}


int mapNoise(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int err = l->p->getMap(l->p, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    c_int mod = (l->mc <= MC_1_6) ? 2 : 299999;

    int i, j;
    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            if (out[i + j * w] > 0) {
                cs = getChunkSeed(ss, i + x, j + z);
                out[i + j * w] = mcFirstInt(cs, mod) + 2;
            } else {
                out[i + j * w] = 0;
            }
        }
    }

    return 0;
}


int mapBamboo(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int err = l->p->getMap(l->p, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    int i, j;
    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int idx = i + j * w;
            if (out[idx] != jungle) continue;

            cs = getChunkSeed(ss, i + x, j + z);
            if (mcFirstIsZero(cs, 10)) { out[idx] = bamboo_jungle; }
        }
    }

    return 0;
}


static int replaceEdge(int* out, c_int idx, c_int mc, c_int v10, c_int v21, c_int v01,
                       c_int v12, c_int id, c_int baseID, c_int edgeID) {
    if (id != baseID) return 0;

    if (areSimilar(mc, v10, baseID) && areSimilar(mc, v21, baseID) && areSimilar(mc, v01, baseID) &&
        areSimilar(mc, v12, baseID))
        out[idx] = id;
    else
        out[idx] = edgeID;

    return 1;
}


int mapBiomeEdge(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;
    c_i8 mc = l->mc;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        c_int* vz0 = out + (j + 0) * pW;
        c_int* vz1 = out + (j + 1) * pW;
        c_int* vz2 = out + (j + 2) * pW;

        for (i = 0; i < w; i++) {
            c_int v11 = vz1[i + 1];
            c_int v10 = vz0[i + 1];
            c_int v21 = vz1[i + 2];
            c_int v01 = vz1[i + 0];
            c_int v12 = vz2[i + 1];

            if (!replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, wooded_badlands_plateau, badlands) &&
                !replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, badlands_plateau, badlands) &&
                !replaceEdge(out, i + j * w, mc, v10, v21, v01, v12, v11, giant_tree_taiga, taiga)) {
                if (v11 == desert) {
                    if (!isAny4(snowy_tundra, v10, v21, v01, v12)) {
                        out[i + j * w] = v11;
                    } else {
                        out[i + j * w] = wooded_mountains;
                    }
                } else if (v11 == swamp) {
                    if (!isAny4(desert, v10, v21, v01, v12) && !isAny4(snowy_taiga, v10, v21, v01, v12) &&
                        !isAny4(snowy_tundra, v10, v21, v01, v12)) {
                        if (!isAny4(jungle, v10, v21, v01, v12) && !isAny4(bamboo_jungle, v10, v21, v01, v12))
                            out[i + j * w] = v11;
                        else
                            out[i + j * w] = jungle_edge;
                    } else {
                        out[i + j * w] = plains;
                    }
                } else {
                    out[i + j * w] = v11;
                }
            }
        }
    }

    return 0;
}


int mapHills(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapHills() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    int err;
    err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    int* riv = out + pW * pH;
    err = l->p2->getMap(l->p2, riv, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_i8 mc = l->mc;
    c_u64 st = l->startSalt;
    c_u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            c_int a11 = out[i + 1 + (j + 1) * pW]; // biome branch
            c_int b11 = riv[i + 1 + (j + 1) * pW]; // river branch
            c_int idx = i + j * w;
            int bn = -1;

            if (mc >= MC_1_7) bn = (b11 - 2) % 29;

            if (bn == 1 && b11 >= 2 && !isShallowOcean(a11)) {
                int m = getMutated(mc, a11);
                if (m > 0) out[idx] = m;
                else
                    out[idx] = a11;
            } else {
                cs = getChunkSeed(ss, i + x, j + z);
                if (bn == 0 || mcFirstIsZero(cs, 3)) {
                    int hillID = a11;

                    switch (a11) {
                        case desert:
                            hillID = desert_hills;
                            break;
                        case forest:
                            hillID = wooded_hills;
                            break;
                        case birch_forest:
                            hillID = birch_forest_hills;
                            break;
                        case dark_forest:
                            hillID = plains;
                            break;
                        case taiga:
                            hillID = taiga_hills;
                            break;
                        case giant_tree_taiga:
                            hillID = giant_tree_taiga_hills;
                            break;
                        case snowy_taiga:
                            hillID = snowy_taiga_hills;
                            break;
                        case plains:
                            if (mc <= MC_1_6) {
                                hillID = forest;
                                break;
                            }
                            cs = mcStepSeed(cs, st);
                            hillID = mcFirstIsZero(cs, 3) ? wooded_hills : forest;
                            break;
                        case snowy_tundra:
                            hillID = snowy_mountains;
                            break;
                        case jungle:
                            hillID = jungle_hills;
                            break;
                        case bamboo_jungle:
                            hillID = bamboo_jungle_hills;
                            break;
                        case ocean:
                            if (mc >= MC_1_7) hillID = deep_ocean;
                            break;
                        case mountains:
                            if (mc >= MC_1_7) hillID = wooded_mountains;
                            break;
                        case savanna:
                            hillID = savanna_plateau;
                            break;
                        default:
                            if (areSimilar(mc, a11, wooded_badlands_plateau)) hillID = badlands;
                            else if (isDeepOcean(a11)) {
                                cs = mcStepSeed(cs, st);
                                if (mcFirstIsZero(cs, 3)) {
                                    cs = mcStepSeed(cs, st);
                                    hillID = mcFirstIsZero(cs, 2) ? plains : forest;
                                }
                            }
                            break;
                    }

                    if (bn == 0 && hillID != a11) {
                        hillID = getMutated(mc, hillID);
                        if (hillID < 0) hillID = a11;
                    }

                    if (hillID != a11) {
                        int a10 = out[i + 1 + (j + 0) * pW];
                        int a21 = out[i + 2 + (j + 1) * pW];
                        int a01 = out[i + 0 + (j + 1) * pW];
                        int a12 = out[i + 1 + (j + 2) * pW];
                        int equals = 0;

                        if (areSimilar(mc, a10, a11)) equals++;
                        if (areSimilar(mc, a21, a11)) equals++;
                        if (areSimilar(mc, a01, a11)) equals++;
                        if (areSimilar(mc, a12, a11)) equals++;

                        if (equals >= 3 + (mc <= MC_1_6)) out[idx] = hillID;
                        else
                            out[idx] = a11;
                    } else {
                        out[idx] = a11;
                    }
                } else {
                    out[idx] = a11;
                }
            }
        }
    }

    return 0;
}


static int reduceID(int id) { return id >= 2 ? 2 + (id & 1) : id; }

int mapRiver(const Layer* l, int* out, int x, int z, int w, int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_i8 mc = l->mc;

    for (j = 0; j < h; j++) {
        int* vz0 = out + (j + 0) * pW;
        int* vz1 = out + (j + 1) * pW;
        int* vz2 = out + (j + 2) * pW;

        for (i = 0; i < w; i++) {
            int v01 = vz1[i + 0];
            int v11 = vz1[i + 1];
            int v21 = vz1[i + 2];
            int v10 = vz0[i + 1];
            int v12 = vz2[i + 1];

            if (mc >= MC_1_7) {
                v01 = reduceID(v01);
                v11 = reduceID(v11);
                v21 = reduceID(v21);
                v10 = reduceID(v10);
                v12 = reduceID(v12);
            } else if (v11 == 0) {
                out[i + j * w] = river;
                continue;
            }

            if (v11 == v01 && v11 == v10 && v11 == v12 && v11 == v21) {
                out[i + j * w] = -1;
            } else {
                out[i + j * w] = river;
            }
        }
    }

    return 0;
}


int mapSmooth(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        c_int* vz0 = out + (j + 0) * pW;
        c_int* vz1 = out + (j + 1) * pW;
        c_int* vz2 = out + (j + 2) * pW;

        for (i = 0; i < w; i++) {
            int v11 = vz1[i + 1];
            int v01 = vz1[i + 0];
            int v10 = vz0[i + 1];

            if (v11 != v01 || v11 != v10) {
                int v21 = vz1[i + 2];
                int v12 = vz2[i + 1];
                if (v01 == v21 && v10 == v12) {
                    cs = getChunkSeed(ss, i + x, j + z);
                    if (cs & ((u64) 1 << 24)) v11 = v10;
                    else
                        v11 = v01;
                } else {
                    if (v01 == v21) v11 = v01;
                    if (v10 == v12) v11 = v10;
                }
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


int mapSunflower(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    int i, j;

    c_int err = l->p->getMap(l->p, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    c_u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v = out[i + j * w];

            if (v == plains) {
                cs = getChunkSeed(ss, i + x, j + z);
                if (mcFirstIsZero(cs, 57)) { out[i + j * w] = sunflower_plains; }
            }
        }
    }

    return 0;
}


static int replaceOcean(int* out, c_int idx, c_int v10, c_int v21, c_int v01, c_int v12,
                        c_int id, c_int replaceID) {
    if (isOceanic(id)) return 0;

    if (isOceanic(v10) || isOceanic(v21) || isOceanic(v01) || isOceanic(v12)) out[idx] = replaceID;
    else
        out[idx] = id;

    return 1;
}

static int isAll4JFTO(c_int mc, c_int a, c_int b, c_int c, c_int d) {
    return (getCategory(mc, a) == jungle || a == forest || a == taiga || isOceanic(a)) &&
           (getCategory(mc, b) == jungle || b == forest || b == taiga || isOceanic(b)) &&
           (getCategory(mc, c) == jungle || c == forest || c == taiga || isOceanic(c)) &&
           (getCategory(mc, d) == jungle || d == forest || d == taiga || isOceanic(d));
}

static int isAny4Oceanic(c_int a, c_int b, c_int c, c_int d) {
    return isOceanic(a) || isOceanic(b) || isOceanic(c) || isOceanic(d);
}

int mapShore(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    c_i8 mc = l->mc;

    for (j = 0; j < h; j++) {
        c_int* vz0 = out + (j + 0) * pW;
        c_int* vz1 = out + (j + 1) * pW;
        c_int* vz2 = out + (j + 2) * pW;

        for (i = 0; i < w; i++) {
            int v11 = vz1[i + 1];
            c_int v10 = vz0[i + 1];
            c_int v21 = vz1[i + 2];
            c_int v01 = vz1[i + 0];
            c_int v12 = vz2[i + 1];

            if (v11 == mushroom_fields) {
                if (isAny4(ocean, v10, v21, v01, v12)) out[i + j * w] = mushroom_field_shore;
                else
                    out[i + j * w] = v11;
                continue;
            }
            if (mc <= MC_1_0) {
                out[i + j * w] = v11;
                continue;
            }

            if (mc <= MC_1_6) {
                if (v11 == mountains) {
                    if (v10 != mountains || v21 != mountains || v01 != mountains || v12 != mountains)
                        v11 = mountain_edge;
                } else if (v11 != ocean && v11 != river && v11 != swamp) {
                    if (isAny4(ocean, v10, v21, v01, v12)) v11 = beach;
                }
                out[i + j * w] = v11;
            } else if (getCategory(mc, v11) == jungle) {
                if (isAll4JFTO(mc, v10, v21, v01, v12)) {
                    if (isAny4Oceanic(v10, v21, v01, v12)) out[i + j * w] = beach;
                    else
                        out[i + j * w] = v11;
                } else {
                    out[i + j * w] = jungle_edge;
                }
            } else if (v11 == mountains || v11 == wooded_mountains /* || v11 == mountain_edge*/) {
                replaceOcean(out, i + j * w, v10, v21, v01, v12, v11, stone_shore);
            } else if (isSnowy(v11)) {
                replaceOcean(out, i + j * w, v10, v21, v01, v12, v11, snowy_beach);
            } else if (v11 == badlands || v11 == wooded_badlands_plateau) {
                if (!isAny4Oceanic(v10, v21, v01, v12)) {
                    if (isMesa(v10) && isMesa(v21) && isMesa(v01) && isMesa(v12)) out[i + j * w] = v11;
                    else
                        out[i + j * w] = desert;
                } else {
                    out[i + j * w] = v11;
                }
            } else {
                if (v11 != ocean && v11 != deep_ocean && v11 != river && v11 != swamp) {
                    if (isAny4Oceanic(v10, v21, v01, v12)) out[i + j * w] = beach;
                    else
                        out[i + j * w] = v11;
                } else {
                    out[i + j * w] = v11;
                }
            }
        }
    }

    return 0;
}


int mapRiverMix(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapRiverMix() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    int err = l->p->getMap(l->p, out, x, z, w, h); // biome chain
    if EXPECT_FALSE (err != 0) return err;

    int idx;
    c_int mc = (unsigned char) l->mc;
    c_int len = w * h;
    int* buf = out + len;

    err = l->p2->getMap(l->p2, buf, x, z, w, h); // rivers
    if EXPECT_FALSE (err != 0) return err;


    for (idx = 0; idx < len; idx++) {
        int v = out[idx];

        if (buf[idx] == river && v != ocean && (mc < MC_1_7 || !isOceanic(v))) {
            if (v == snowy_tundra) v = frozen_river;
            else if (v == mushroom_fields || v == mushroom_field_shore)
                v = mushroom_fields;
            else
                v = river;
        }

        out[idx] = v;
    }

    return 0;
}


int mapOceanTemp(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    int i, j;
    // const PerlinNoise *rnd = (const PerlinNoise*) l->noise;

    u64 ss = l->startSeed;
    u64 cs;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            cs = getChunkSeed(ss, i + x, j + z);

            int tmp = mcFirstInt(cs, 100);

            if (tmp < 8) out[i + j * w] = warm_ocean;
            else if (tmp < 40)
                out[i + j * w] = lukewarm_ocean;
            else if (tmp < 68)
                out[i + j * w] = ocean;
            else if (tmp < 95)
                out[i + j * w] = cold_ocean;
            else
                out[i + j * w] = frozen_ocean;


            // float tmp = mcFirstInt(cs, 100) / 100.0F;

            // if (tmp < 0.075F)
            //     out[i + j*w] = warm_ocean;
            // else if (tmp < 0.4F)
            //     out[i + j*w] = lukewarm_ocean;
            // else if (tmp < 0.675F)
            //     out[i + j*w] = ocean;
            // else if (tmp < 0.95F)
            //     out[i + j*w] = cold_ocean;
            // else
            //     out[i + j*w] = frozen_ocean;


            // double tmp = samplePerlin(rnd, (i + x) / 8.0, (j + z) / 8.0, 0, 0, 0);

            // if (tmp > 0.4)
            //     out[i + j*w] = warm_ocean;
            // else if (tmp > 0.2)
            //     out[i + j*w] = lukewarm_ocean;
            // else if (tmp < -0.4)
            //     out[i + j*w] = frozen_ocean;
            // else if (tmp < -0.2)
            //     out[i + j*w] = cold_ocean;
            // else
            //     out[i + j*w] = ocean;
        }
    }

    return 0;
}


int mapOceanMix(const Layer* l, int* out, int x, int z, int w, int h) {
    int i, j;
    int lx0, lx1, lz0, lz1, lw, lh;

    if EXPECT_FALSE (l->p2 == nullptr) {
        printf("mapOceanMix() requires two parents! Use setupMultiLayer()\n");
        exit(1);
    }

    int err = l->p2->getMap(l->p2, out, x, z, w, h);
    if EXPECT_FALSE (err != 0) return err;

    // determine the minimum required land area: (x+lx0, z+lz0), (lw, lh)
    // (the extra border is only required if there is warm or frozen ocean)
    lx0 = 0;
    lx1 = w;
    lz0 = 0;
    lz1 = h;

    for (j = 0; j < h; j++) {
        int jCenter = (j - 8 > 0 && j + 9 < h);
        for (i = 0; i < w; i++) {
            if (jCenter && i - 8 > 0 && i + 9 < w) continue;
            int oceanID = out[i + j * w];
            if (oceanID == warm_ocean || oceanID == frozen_ocean) {
                if (i - 8 < lx0) lx0 = i - 8;
                if (i + 9 > lx1) lx1 = i + 9;
                if (j - 8 < lz0) lz0 = j - 8;
                if (j + 9 > lz1) lz1 = j + 9;
            }
        }
    }

    int* land = out + w * h;
    lw = lx1 - lx0;
    lh = lz1 - lz0;
    err = l->p->getMap(l->p, land, x + lx0, z + lz0, lw, lh);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int landID = land[(i - lx0) + (j - lz0) * lw];
            int oceanID = out[i + j * w];
            int replaceID = 0;
            int ii, jj;

            if (!isOceanic(landID)) {
                out[i + j * w] = landID;
                continue;
            }

            if (oceanID == warm_ocean) replaceID = lukewarm_ocean;
            if (oceanID == frozen_ocean) replaceID = cold_ocean;
            if (replaceID) {
                for (ii = -8; ii <= 8; ii += 4) {
                    for (jj = -8; jj <= 8; jj += 4) {
                        c_int id = land[(i + ii - lx0) + (j + jj - lz0) * lw];
                        if (!isOceanic(id)) {
                            out[i + j * w] = replaceID;
                            goto loop_x;
                        }
                    }
                }
            }

            if (landID == deep_ocean) {
                switch (oceanID) {
                    case lukewarm_ocean:
                        oceanID = deep_lukewarm_ocean;
                        break;
                    case ocean:
                        oceanID = deep_ocean;
                        break;
                    case cold_ocean:
                        oceanID = deep_cold_ocean;
                        break;
                    case frozen_ocean:
                        oceanID = deep_frozen_ocean;
                        break;
                    default:
                        break;
                }
            }

            out[i + j * w] = oceanID;

        loop_x:;
        }
    }

    return 0;
}

int mapGMushroom(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        for (i = 0; i < w; i++) {
            int v11 = out[i + 1 + (j + 1) * pW];

            if (out[i + 0 + (j + 0) * pW] == mushroom_fields || out[i + 2 + (j + 0) * pW] == mushroom_fields ||
                out[i + 0 + (j + 2) * pW] == mushroom_fields || out[i + 2 + (j + 2) * pW] == mushroom_fields) {
                v11 = mushroom_fields;
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}

int mapOceanEdge(const Layer* l, int* out, c_int x, c_int z, c_int w, c_int h) {
    c_int pX = x - 1;
    c_int pZ = z - 1;
    c_int pW = w + 2;
    c_int pH = h + 2;
    int i, j;

    c_int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
    if EXPECT_FALSE (err != 0) return err;

    for (j = 0; j < h; j++) {
        int* vz0 = out + (j + 0) * pW;
        int* vz1 = out + (j + 1) * pW;
        int* vz2 = out + (j + 2) * pW;

        for (i = 0; i < w; i++) {
            int v11 = vz1[i + 1];
            int v10 = vz0[i + 1];
            int v21 = vz1[i + 2];
            int v01 = vz1[i + 0];
            int v12 = vz2[i + 1];

            if ((v11 == warm_ocean && isAny4(frozen_ocean, v10, v21, v01, v12)) ||
                (v11 == frozen_ocean && isAny4(warm_ocean, v10, v21, v01, v12))) {
                v11 = ocean;
            }

            out[i + j * w] = v11;
        }
    }

    return 0;
}


static void getVoronoiCell(c_u64 sha, c_int a, c_int b, c_int c, int* x, int* y, int* z) {
    u64 s = sha;
    s = mcStepSeed(s, a);
    s = mcStepSeed(s, b);
    s = mcStepSeed(s, c);
    s = mcStepSeed(s, a);
    s = mcStepSeed(s, b);
    s = mcStepSeed(s, c);

    *x = (((s >> 24) & 1023) - 512) * 36;
    s = mcStepSeed(s, sha);
    *y = (((s >> 24) & 1023) - 512) * 36;
    s = mcStepSeed(s, sha);
    *z = (((s >> 24) & 1023) - 512) * 36;
}

int mapVoronoi114(const Layer* l, int* out, int x, int z, int w, int h) {
    x -= 2;
    z -= 2;
    int pX = x >> 2;
    int pZ = z >> 2;
    int pW = ((x + w) >> 2) - pX + 2;
    int pH = ((z + h) >> 2) - pZ + 2;

    if (l->p) {
        int err = l->p->getMap(l->p, out, pX, pZ, pW, pH);
        if (err != 0) return err;
    }

    int i, j, ii, jj, pi, pj, pix, pjz, i4, j4, mi, mj;
    int v00, v01, v10, v11, v;
    i64 da1, da2, db1, db2, dc1, dc2, dd1, dd2;
    i64 sja, sjb, sjc, sjd, da, db, dc, dd;
    int* buf = out + pW * pH;

    u64 st = l->startSalt;
    u64 ss = l->startSeed;
    u64 cs;

    for (pj = 0; pj < pH - 1; pj++) {
        v00 = out[(pj + 0) * pW];
        v01 = out[(pj + 1) * pW];
        pjz = pZ + pj;
        j4 = ((pjz) << 2) - z;

        for (pi = 0; pi < pW - 1; pi++, v00 = v10, v01 = v11) {
            pix = pX + pi;
            i4 = ((pix) << 2) - x;

            // try to prefetch the relevant rows to help prevent cache misses
            PREFETCH(buf + ((pjz << 2) + 0) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 1) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 2) * w + pi, 1, 1);
            PREFETCH(buf + ((pjz << 2) + 3) * w + pi, 1, 1);

            v10 = out[pi + 1 + (pj + 0) * pW];
            v11 = out[pi + 1 + (pj + 1) * pW];

            if (v00 == v01 && v00 == v10 && v00 == v11) {
                for (jj = 0; jj < 4; jj++) {
                    j = j4 + jj;
                    if (j < 0 || j >= h) continue;
                    for (ii = 0; ii < 4; ii++) {
                        i = i4 + ii;
                        if (i < 0 || i >= w) continue;
                        buf[j * w + i] = v00;
                    }
                }
                continue;
            }

            cs = getChunkSeed(ss, (pi + pX) << 2, (pj + pZ) << 2);
            da1 = (mcFirstInt(cs, 1024) - 512) * 36;
            cs = mcStepSeed(cs, st);
            da2 = (mcFirstInt(cs, 1024) - 512) * 36;

            cs = getChunkSeed(ss, (pi + pX + 1) << 2, (pj + pZ) << 2);
            db1 = (mcFirstInt(cs, 1024) - 512) * 36 + 40 * 1024;
            cs = mcStepSeed(cs, st);
            db2 = (mcFirstInt(cs, 1024) - 512) * 36;

            cs = getChunkSeed(ss, (pi + pX) << 2, (pj + pZ + 1) << 2);
            dc1 = (mcFirstInt(cs, 1024) - 512) * 36;
            cs = mcStepSeed(cs, st);
            dc2 = (mcFirstInt(cs, 1024) - 512) * 36 + 40 * 1024;

            cs = getChunkSeed(ss, (pi + pX + 1) << 2, (pj + pZ + 1) << 2);
            dd1 = (mcFirstInt(cs, 1024) - 512) * 36 + 40 * 1024;
            cs = mcStepSeed(cs, st);
            dd2 = (mcFirstInt(cs, 1024) - 512) * 36 + 40 * 1024;

            for (jj = 0; jj < 4; jj++) {
                j = j4 + jj;
                if (j < 0 || j >= h) continue;

                mj = 10240 * jj;
                sja = (mj - da2) * (mj - da2);
                sjb = (mj - db2) * (mj - db2);
                sjc = (mj - dc2) * (mj - dc2);
                sjd = (mj - dd2) * (mj - dd2);

                for (ii = 0; ii < 4; ii++) {
                    i = i4 + ii;
                    if (i < 0 || i >= w) continue;

                    mi = 10240 * ii;
                    da = (mi - da1) * (mi - da1) + sja;
                    db = (mi - db1) * (mi - db1) + sjb;
                    dc = (mi - dc1) * (mi - dc1) + sjc;
                    dd = (mi - dd1) * (mi - dd1) + sjd;

                    if EXPECT_FALSE ((da < db) && (da < dc) && (da < dd)) v = v00;
                    else if EXPECT_FALSE ((db < da) && (db < dc) && (db < dd))
                        v = v10;
                    else if EXPECT_FALSE ((dc < da) && (dc < db) && (dc < dd))
                        v = v01;
                    else
                        v = v11;

                    buf[j * w + i] = v;
                }
            }
        }
    }

    memmove(out, buf, w * h * sizeof(*buf));

    return 0;
}
